(defvar *canvas* (chain document (get-element-by-id "canvas")))
(defvar *ctx* (chain *canvas* (get-context "2d")))
(defvar *width* (@ window inner-width))
(defvar *height* (@ window inner-height))
(setf (@ *canvas* width) *width*
      (@ *canvas* height) *height*)
(var width *width*)
(var height *height*)

(defun remove-dead-particles (particles)
  (do ((i (1- (@ particles length)) (1- i)))
      ((< i 0))
    (let ((p (aref particles i)))
      (with-slots (x y radius) p
        (when (or (> (- x radius) width)
                  (< (+ x radius) 0)
                  (> (- y radius) height)
                  (< (+ y radius) 0))
          (chain particles (splice i 1)))))))

(defun wrap (p)
  (with-slots (x y radius) p
    (when (> (- x radius) width)
      (setf x (- radius)))
    (when (< (+ x radius) 0)
      (setf x (+ width radius)))
    (when (> (- y radius) height)
      (setf y (- radius)))
    (when (< (+ y radius) 0)
      (setf y (+ height radius)))))

(defun bounce (p)
  (with-slots (x y vx vy radius bounce) p
    (when (> (+ x radius) width)
      (setf x (- width radius)
            vx (* vx bounce)))
    (when (< (- x radius) 0)
      (setf x radius
            vx (* vx bounce)))
    (when (> (+ y radius) height)
      (setf y (- height radius)
            vy (* vy bounce)))
    (when (< (- y radius) 0)
      (setf y radius
            vy (* vy bounce)))))

(defun draw-particle (p)
  (ctx begin-path)
  (ctx arc (particle-x p) (particle-y p) (particle-radius p) 0 (* pi 2) false)
  (ctx fill))

(defun render-arm (arm)
  (setf (ctx-get stroke-style) "#000000"
        (ctx-get line-width) 5)
  (ctx begin-path)
  (ctx move-to (@ arm x) (@ arm y))
  (ctx line-to (arm-end-x arm) (arm-end-y arm))
  (ctx stroke))

(defun render-fk-system (fk-system)
  (dolist (arm (@ fk-system arms))
    (render-arm arm)))

(defun render-ik-system (ik-system)
  (dolist (arm (@ ik-system arms))
    (with-slots (x y angle length) arm
      (setf (ctx-get stroke-style) "#000000"
            (ctx-get line-width) 5)
      (ctx begin-path)
      (ctx move-to x y)
      (ctx line-to (+ x (* (cos angle) length)) (+ y (* (sin angle) length)))
      (ctx stroke))))

(defun ep-1 ()
  "Introduction"
  (dotimes (_ 100)
    (ctx begin-path)
    (ctx move-to (random-range 0 width) (random-range 0 height))
    (ctx line-to (random-range 0 width) (random-range 0 height))
    (ctx stroke)))

(defun ep-2 ()
  "Intro to Trigonometry"
  (ctx translate 0 (/ height 2))
  (ctx scale 1 -1)
  (do ((angle 0 (+ angle 0.01)))
      ((>= angle (* pi 2)))
    (ctx fill-rect (* angle (/ width (* 2 pi))) (* (sin angle) (/ width (* 2 pi))) 5 5)))

(defun ep-3 ()
  "More Trigonometry"
  (let ((center-y (* height 0.5))
        (center-x (* width 0.5))
        (base-radius 50)
        (base-alpha 0.5)
        (offset-height (* height 0.4))
        (offset-radius 30)
        (offset-alpha 0.5)
        (speed 0.1)
        (angle 0))
    (def-animation-loop render
      (clear)
      (setf y (+ center-y (* (sin angle) offset-height))
            radius (+ base-radius (* (sin (/ angle 2)) offset-radius))
            alpha (+ base-alpha (* (sin (/ angle 2)) offset-alpha))
            (ctx-get fill-style) (concatenate 'string "rgba(0, 0, 0, " alpha ")"))
      (clear)
      (ctx begin-path)
      (ctx arc center-x y radius 0 (* pi 2) false)
      (ctx fill)
      (incf angle speed))
    (render)))

(defun ep-4 ()
  "Circles, Ellipses and Lissajous Curves"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (x-radius (/ width 6))
        (y-radius (/ height 3))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.1)
        (y-speed 0.131)
        x y)
    (def-animation-loop render
      (clear)
      (setf x (+ center-x (* (cos x-angle) x-radius))
            y (+ center-y (* (sin y-angle) y-radius)))
      (ctx begin-path)
      (ctx arc x y 10 0 (* pi 2) false)
      (ctx fill)
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (render)))


(defun ep-5 ()
  "Arctangent"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (arrow-x (/ width 2))
        (arrow-y (/ height 2))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.01)
        (y-speed 0.02)
        dx
        dy
        (angle 0))
    (def-animation-loop render
      (clear)
      (setf arrow-x (+ center-x (* (cos x-angle) (/ width 6)))
            arrow-y (+ center-y (* (sin y-angle) (/ height 3))))
      (with-context ()
        (ctx translate arrow-x arrow-y)
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 20 0)
        (ctx line-to -20 0)
        (ctx move-to 20 0)
        (ctx line-to 10 -10)
        (ctx move-to 20 0)
        (ctx line-to 10 10)
        (ctx stroke))
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf dx (- (@ evt client-x) arrow-x)
                                    dy (- (@ evt client-y) arrow-y)
                                    angle (chain *math (atan2 dy dx))))))
    (render)))

(defun ep-6 ()
  "Vectors, Part I")

(defun ep-7 ()
  "Vectors, Part II"
  (setf v (make-vector 10 5))
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))
  (chain console (log (vec-angle v)))
  (chain console (log (vec-length v)))
  (setf (vec-angle v) (/ pi 6))
  (setf (vec-length v) 100)
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4)
        v3 (v+ v1 v2))
  (chain console (log (vec-x v3)))
  (chain console (log (vec-y v3)))

  (setf v1 (make-vector 10 5)
        v2 (v* v1 2))
  (chain console (log (vec-length v1)))
  (chain console (log (vec-length v2)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4))
  (v+! v1 v2)
  (chain console (log (vec-x v1) (vec-y v1))))

(defun ep-8 ()
  "Velocity"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 2)
                                   (random-range 1 5)
                                   (random-range 0 (* pi 2))))))
    (def-animation-loop update
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 10 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-9 ()
  "Acceleration"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 3)
                                   (random-range 2 7)
                                   (random-range 0 (* pi 2))
                                   0.1))))
    (def-animation-loop update
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 4 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-10 ()
  "Advanced Acceleration"
  (let ((ship (make-particle (/ width 2) (/ height 2) 0 0))
        (thrust (make-vector 0 0))
        (angle 0)
        (turing-left nil)
        (turing-right nil)
        (thrusting nil))
    ;; (setf (particle-friction ship) 0.99) ; from ep-13
    (chain document body (add-event-listener
                          "keydown"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting t)) ; up
                                (37 (setf turing-left t)) ; left
                                (39 (setf turing-right t)))))) ; right
    (chain document body (add-event-listener
                          "keyup"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting nil))
                                (37 (setf turing-left nil))
                                (39 (setf turing-right nil))))))
    (def-animation-loop update
      (clear)
      (when turing-left
        (decf angle 0.05))
      (when turing-right
        (incf angle 0.05))
      (setf (vec-angle thrust) angle
            (vec-length thrust) (if thrusting 0.1 0))
      (particle-accelerate! ship thrust)
        (particle-update! ship)
      (with-context
        (ctx translate (particle-x ship) (particle-y ship))
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 10 0)
        (ctx line-to -10 -7)
        (ctx line-to -10 7)
        (ctx line-to 10 0)
        (when thrusting
          (ctx move-to -10 0)
          (ctx line-to -18 0))
        (ctx stroke))
      (when (> (particle-x ship) width)
        (setf (particle-x ship) 0))
      (when (< (particle-x ship) 0)
        (setf (particle-x ship) width))
      (when (> (particle-y ship) height)
        (setf (particle-y ship) 0))
      (when (< (particle-y ship) 0)
        (setf (particle-y ship) height)))
    (update)))

(defun ep-11 ()
  "Gravity"
  (let ((sun (make-particle (/ width 2) (/ height 2) 0 0))
        (planet (make-particle (+ (/ width 2) 200) (/ height 2) 10 (/ pi -2))))
    (setf (particle-mass sun) 20000)
    (particle-gravitation-add! planet sun)
    (def-animation-loop update
      (clear)
      (particle-update! planet)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#ffff00")
      (ctx arc (particle-x sun) (particle-y sun) 20 0 (* pi 2) false)
      (ctx fill)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#0000ff")
      (ctx arc (particle-x planet) (particle-y planet) 5 0 (* pi 2) false)
      (ctx fill))
    (update)))

(defun ep-12 ()
  "Edge Handling"
  (let* ((num-particles 100)
         (particles
           (loop repeat num-particles
                 collect (let ((particle (make-particle
                                          (/ width 2)
                                          height
                                          (random-range 5 13)
                                          (+ (/ pi -2) (random-range -0.1 0.1))
                                          0.1)))
                           (setf (particle-radius particle) (random-range 2 12)
                                 (particle-bounce particle) -0.9)
                           particle))))

    (defun regenerate (p)
      (with-slots (x y vx vy radius velocity) p
        (when (> (- y radius) height)
          (let ((speed (random-range 5 13))
                (direction (+ (/ pi -2) (random-range -0.1 0.1))))
            (setf x (/ width 2)
                  y height
                  vx (* (cos direction) speed)
                  vy (* (sin direction) speed))))))

    (def-animation-loop update ()
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (draw-particle p)
        ;; (wrap p)
        ;; (regenerate p)
        (bounce p)
        )
      ;; (chain (remove-dead-particles particles))
      )
    (update)))

(defun ep-13 ()
  "Friction"
  (let ((p (make-particle
            (/ width 2)
            (/ height 2)
            10
            (random-range 0 (* pi 2))))
        (friction 0.97))
    (setf (particle-radius p) 10)
    (def-animation-loop update
      (clear)
      (with-slots (vx vy) p
        (setf vx (* vx friction)
              vy (* vy friction))
        (particle-update! p)
        (draw-particle p)))
    (update)))

(defun ep-14 ()
  "Collision Detection"
  (let ((circle0 (create x (random-range 0 width)
                         y (random-range 0 height)
                         radius (random-range 50 150)))
        (circle1 (create x (random-range 0 width)
                         y (random-range 0 height)
                         radius (random-range 50 150)))
        (rect0 (create x 200 y 200 width 200 height 100))
        (rect1 (create x 0 y 0 width 100 height 200)))
    (labels ((draw-circle (circle)
               (with-slots (x y radius) circle
                 (ctx begin-path)
                 (ctx arc x y radius 0 (* pi 2) false)
                 (ctx fill)))
             (draw-rect (rect)
               (with-slots (x y width height) rect
                 (ctx fill-rect x y width height)))
             (pick-color (collide)
               (if collide "#f66" "#999"))
             (detect-point-and-circle (evt)
               (setf (ctx-get fill-style)
                     (pick-color (circle-point-collision (@ evt client-x) (@ evt client-y) circle0)))
               (draw-circle circle0))
             (detect-circle-and-circle (evt)
               (clear)
               (setf (@ circle1 x) (@ evt client-x)
                     (@ circle1 y) (@ evt client-y)
                     (ctx-get fill-style) (pick-color (circle-collision circle0 circle1)))
               (draw-circle circle0)
               (draw-circle circle1))
             (detect-point-and-rect (evt)
               (setf (ctx-get fill-style)
                     (pick-color (point-in-rect (@ evt client-x) (@ evt client-y) rect0)))
               (draw-rect rect0))
             (detect-rect-and-rect (evt)
               (clear)
               (setf (@ rect1 x) (- (@ evt client-x) 50)
                     (@ rect1 y) (- (@ evt client-y) 100)
                     (ctx-get fill-style) (pick-color (rect-intersect rect0 rect1)))
               (draw-rect rect0)
               (draw-rect rect1)))
      (chain document body (add-event-listener
                            "mousemove"
                            ;; #'detect-point-and-circle
                            ;; #'detect-circle-and-circle
                            ;; #'detect-point-and-rect
                            #'detect-rect-and-rect
                            )))))

(defun ep-15 ()
  "Springs Part 1"
  (let ((spring-point (make-vector (/ width 2) (/ height 2)))
        (weight (make-particle
                 (random-range 0 width)
                 (random-range 0 height)
                 50
                 (random-range 0 (* pi 2))))
        (k 0.1))
    (setf (particle-radius weight) 20
          (particle-friction weight) 0.9)
    (particle-spring-add! weight spring-point k)
    (def-animation-loop update ()
      (clear)
      (with-slots (x y radius) weight
        (particle-update! weight)
        (ctx begin-path)
        (ctx arc x y radius 0 (* pi 2) false)
        (ctx fill)
        (ctx begin-path)
        (ctx arc (vec-x spring-point) (vec-y spring-point) 4 0 (* pi 2) false)
        (ctx fill)
        (ctx begin-path)
        (ctx move-to x y)
        (ctx line-to (vec-x spring-point) (vec-y spring-point))
        (ctx stroke)))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf (vec-x spring-point) (@ evt client-x)
                                    (vec-y spring-point) (@ evt client-y)))))
    (update)))

(defun ep-16 ()
  "Springs Part 2"
  (let ((spring-point (make-vector (/ width 2) (/ height 2)))
        (particle-a (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (particle-b (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (particle-c (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (k 0.01)
        (separation 200))
    (setf (particle-friction particle-a) 0.9
          (particle-radius particle-a) 20
          (particle-friction particle-b) 0.9
          (particle-radius particle-b) 20
          (particle-friction particle-c) 0.9
          (particle-radius particle-c) 20)
    (particle-spring-add! particle-a particle-b k separation)
    (particle-spring-add! particle-a particle-c k separation)
    (particle-spring-add! particle-b particle-a k separation)
    (particle-spring-add! particle-b particle-c k separation)
    (particle-spring-add! particle-c particle-a k separation)
    (particle-spring-add! particle-c particle-b k separation)
    (def-animation-loop update
      (clear)
      (bounce particle-a)
      (bounce particle-b)
      (bounce particle-c)
      (particle-update! particle-a)
      (particle-update! particle-b)
      (particle-update! particle-c)
      (draw-particle particle-a)
      (draw-particle particle-b)
      (draw-particle particle-c)
      (ctx begin-path)
      (ctx move-to (particle-x particle-a) (particle-y particle-a))
      (ctx line-to (particle-x particle-b) (particle-y particle-b))
      (ctx line-to (particle-x particle-c) (particle-y particle-c))
      (ctx line-to (particle-x particle-a) (particle-y particle-a))
      (ctx stroke))
    (update)))

(defun ep-17 ()
  "Particles - Optimization")

(defun ep-18 ()
  "Particles - Enhancements"
  (let* ((sun1 (make-particle 300 200 0 0))
         (sun2 (make-particle 800 600 0 0))
         (emitter (create x 100 y 0))
         (num-particles 100)
         (particles (loop repeat num-particles
                          collect (let ((p (make-particle
                                             (@ emitter x)
                                             (@ emitter y)
                                             (random-range 7 8)
                                             (+ (/ pi 2) (random-range -0.1 0.1)))))
                                     (particle-gravitation-add! p sun1)
                                     (particle-gravitation-add! p sun2)
                                     (setf (particle-radius p) 3)
                                    p))))
    (setf (particle-mass sun1) 10000
          (particle-radius sun1) 10
          (particle-mass sun2) 20000
          (particle-radius sun2) 20)
    (labels ((draw (p color)
               (setf (ctx-get fill-style) color)
               (draw-particle p)))
      (def-animation-loop update
        (clear)
        (draw sun1 "yellow")
        (draw sun2 "yellow")
        (dolist (p particles)
          (particle-update! p)
          (draw p "black")
          (with-slots (x y) p
            (when (or (> x width)
                      (< x 0)
                      (> y height)
                      (< y 0))
              (setf x (@ emitter x)
                    y (@ emitter y)
                    (particle-speed p) (random-range 7 8)
                    (particle-heading p) (+ (/ pi 2) (random-range -0.1 0.1)))))))
      (update))))

(defun ep-19 ()
  "Bezier Curves"
  (let ((p0 (make-vector (random-range 0 width) (random-range 0 height)))
        (p1 (make-vector (random-range 0 width) (random-range 0 height)))
        (p2 (make-vector (random-range 0 width) (random-range 0 height)))
        (p3 (make-vector (random-range 0 width) (random-range 0 height)))
        (k 0)
        (direction 0.01)
        (p-final (create)))
    (def-animation-loop draw
      (clear)
      (ctx begin-path)
      (ctx move-to (@ p0 x) (@ p0 y))
      (ctx bezier-curve-to (@ p1 x) (@ p1 y) (@ p2 x) (@ p2 y) (@ p3 x) (@ p3 y))
      (ctx stroke)
      (cubic-bezier p0 p1 p2 p3 k p-final)
      (ctx begin-path)
      (ctx arc (@ p-final x) (@ p-final y) 10 0 (* pi 2) false)
      (ctx fill)
      (incf k direction)
      (when (or (> k 1) (< k 0))
        (setf direction (- direction))))
    (draw)))

(defun ep-20 ()
  "More on Bezier Curves"
  (let* ((p0 (make-vector (random-range 0 width) (random-range 0 height)))
         (p1 (make-vector (random-range 0 width) (random-range 0 height)))
         (p2 (make-vector (random-range 0 width) (random-range 0 height)))
         (cp (make-vector (- (* (@ p1 x) 2) (/ (+ (@ p0 x) (@ p2 x)) 2))
                          (- (* (@ p1 y) 2) (/ (+ (@ p0 y) (@ p2 y)) 2))))
         (num-points 10)
         (points (loop repeat num-points
                       collect (make-vector (random-range 0 width) (random-range 0 height)))))
    (labels ((draw-point (p)
               (ctx begin-path)
               (ctx arc (@ p x) (@ p y) 3 0 (* pi 2) false)
               (ctx fill)))
      (dolist (p points)
        (draw-point p))

      (setf (ctx-get stroke-style) "lightgray")
      (ctx begin-path)
      (ctx move-to (@ (aref points 0) x) (@ (aref points 0) y))
      (do* ((i 1 (1+ i))
            (p (aref points i) (aref points i)))
           ((>= i num-points))
        (ctx line-to (@ p x) (@ p y))
        (ctx stroke))

      (setf (ctx-get stroke-style) "black")
      (ctx begin-path)
      (multicurve points *ctx*)
      (ctx stroke))))

(defun ep-21 ()
  "Bitmap Collision Detection"
  (let ((element (chain document (create-element "canvas"))))
    (setf (@ element id) "target")
    (chain document body (append-child element))
    (dolist (el (chain document (query-selector-all "canvas")))
      (with-slots (display position top left) (@ el style)
        (setf display "block"
              position "absolute"
              top "0px"
              left "0px"))))
  (let* ((target-canvas (chain document (get-element-by-id "target")))
         (target-ctx (chain target-canvas (get-context "2d")))
         (p (make-particle 0 (/ height 2) 10 0)))
    (setf (@ target-canvas width) *width*
          (@ target-canvas height) *height*)
    (chain target-ctx (begin-path))
    (chain target-ctx (arc (/ width 2) (/ height 2) 200 0 (* pi 2) false))
    (chain target-ctx (fill))
    (labels ((reset-particle (p)
               (setf (particle-x p) 0
                     (particle-y p) (/ height 2)
                     (particle-heading p) (random-range -0.1 0.1))))
      (def-animation-loop update
        (clear)
        (with-slots (x y) p
          (particle-update! p)
          (ctx begin-path)
          (ctx arc x y 4 0 (* pi 2) false)
          (ctx fill)
          (let ((image-data (chain target-ctx (get-image-data x y 1 1))))
            (cond ((> (aref (@ image-data data) 3) 0)
                   (progn
                     (setf (@ target-ctx global-composite-operation) "destination-out")
                     (chain target-ctx (begin-path))
                     (chain target-ctx (arc x y 20 0 (* pi 2) false))
                     (chain target-ctx (fill))
                     (reset-particle p)))
                  ((> x width) (reset-particle p)))))))
    (update)))

(defun ep-22 ()
  "3D - Postcards in Space"
  (let* ((fl 300)
         (num-shapes 100)
         (shapes (loop repeat num-shapes
                       collect (create x (random-range -1000 1000)
                                       y (random-range -1000 1000)
                                       z (random-range 0 10000)))))
    (ctx translate (/ width 2) (/ height 2))
    (def-animation-loop update
      (ctx clear-rect (/ width -2) (/ height -2) width height)
      (dolist (shape shapes)
        (with-slots (x y z) shape
          (let ((perspective (/ fl (+ fl z))))
            (with-context
              (ctx translate (* x perspective) (* y perspective))
              (ctx scale perspective perspective)
              (ctx fill-rect -100 -100 200 200))
            (incf z 5)
            (when (> z 10000)
              (setf z 0))))))
    (update)))

(defun ep-23 ()
  "3D Carousel"
  (let* ((fl 300)
         (num-cards 7)
         (center-z 1000)
         (radius 1000)
         (base-angle 0)
         (rotation-speed 0.01)
         (cards []))
    (loop for i from 0 to (1- num-cards)
          do (let* ((y 0)
                    (angle (/ (* pi 2 i) num-cards))
                    (img (chain document (create-element "img")))
                    (x (* (cos (+ angle base-angle)) radius))
                    (z (+ center-z (* (sin (+ angle base-angle)) radius))))
               (setf (@ img src) (+ "http://picsum.photos/id/" i "/300/200"))
               (chain cards (push (create x x y y z z angle angle img img)))))
    (ctx translate (/ width 2) (/ height 2))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf rotation-speed (* (- (@ evt client-x) (/ width 2)) 0.00005)))))
    (labels ((zsort (card-a card-b)
               (- (@ card-b z) (@ card-a z))))
      (def-animation-loop update
        (incf base-angle rotation-speed)
        (chain cards (sort zsort))
        (ctx clear-rect (/ width -2) (/ height -2) width height)
        (dolist (card cards)
          (with-slots (x y z angle img) card
            (let ((perspective (/ fl (+ fl z))))
              (with-context
                (ctx scale perspective perspective)
                (ctx translate x y)
                (ctx translate (/ (@ img width) -2) (/ (@ img height) -2))
                (ctx draw-image img 0 0)))
            (setf x (* (cos (+ angle base-angle)) radius)
                  z (+ center-z (* (sin (+ angle base-angle)) radius)))))))
    (update)))

(defun ep-24 ()
  "3D Points and Lines"
  (let* ((fl 300)
         (num-points 200)
         (center-z 2000)
         (radius 1000)
         (base-angle 0)
         (rotation-speed 0.01)
         (points (loop for i from 0 to (1- num-points)
                       collect (let* ((angle (* 0.2 i))
                                      (y (+ (- 2000 (/ (* 4000 i) num-points))
                                            (* (random) 500)))
                                      (x (* (cos (+ angle base-angle)) radius))
                                      (z (+ center-z (* (sin (+ angle base-angle)) radius))))
                                 (create x x y y z z angle angle)))))
    (ctx translate (/ width 2) (/ height 2))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf rotation-speed (* (- (@ evt client-x) (/ width 2)) 0.00005)
                                    ypos (* (- (@ evt client-y) (/ height 2)) 2)))))
  (def-animation-loop update
    (incf base-angle rotation-speed)
    (ctx clear-rect (/ width -2) (/ height -2) width height)
    (ctx begin-path)
    (dotimes (i (@ points length))
      (with-slots (x y z angle) (aref points i)
        (let ((perspective (/ fl (+ fl z))))
          (with-context
            (ctx scale perspective perspective)
            (ctx translate x y)
            (if (= 0 i)
                (ctx move-to 0 0)
                (ctx line-to 0 0))))
        (setf x (* (cos (+ angle base-angle)) radius)
              z (+ center-z (* (sin (+ angle base-angle)) radius)))))
    (ctx stroke))
    (update)))

(defun ep-25 ()
  "3D Modeling, Points and Lines Part 2"
  (let ((fl 300)
        (points (array (create x -500 y -500 z 1000)
                       (create x 500 y -500 z 1000)
                       (create x 500 y -500 z 500)
                       (create x -500 y -500 z 500)
                       (create x -500 y 500 z 1000)
                       (create x 500 y 500 z 1000)
                       (create x 500 y 500 z 500)
                       (create x -500 y 500 z 500)))
        (needs-update t))
    (ctx translate (/ width 2) (/ height 2))
    (labels ((project ()
               (dolist (p points)
                 (with-slots (x y z) p
                   (let ((scale (/ fl (+ fl z))))
                     (setf (@ p sx) (* x scale)
                           (@ p sy) (* y scale))))))
             (draw-line ()
               (let ((p (aref points (aref arguments 0))))
                 (ctx move-to (@ p sx) (@ p sy))
                 (loop for i from 1 to (1- (@ arguments length))
                       do (let ((p (aref points (aref arguments i))))
                            (ctx line-to (@ p sx) (@ p sy))))))
             (translate-model (x y z)
               (dolist (p points)
                 (incf (@ p x) x)
                 (incf (@ p y) y)
                 (incf (@ p z) z))
               (setf needs-update t)))
      (chain document body (add-event-listener
                            "keydown"
                            #'(lambda (evt)
                                (case (@ evt key-code)
                                  (37 (translate-model -20 0 0))
                                  (39 (translate-model 20 0 0))
                                  (38 (if (@ evt shift-key)
                                          (translate-model 0 0 20)
                                          (translate-model 0 -20 0)))
                                  (40 (if (@ evt shift-key)
                                          (translate-model 0 0 -20)
                                          (translate-model 0 20 0)))))))
      (def-animation-loop update
        (when needs-update
          (ctx clear-rect (/ width -2) (/ height -2) width height)
          (project)
          (ctx begin-path)
          (draw-line 0 1 2 3 0)
          (draw-line 4 5 6 7 4)
          (draw-line 0 4)
          (draw-line 1 5)
          (draw-line 2 6)
          (draw-line 3 7)
          (ctx stroke)
          (setf needs-update nil))))
    (update)))

(defun ep-26 ()
  "2D and 3D Coordinate Rotation"
  (let ((fl 300)
        (center-z 1500)
        (points (array (create x -500 y -500 z 500)
                       (create x 500 y -500 z 500)
                       (create x 500 y -500 z -500)
                       (create x -500 y -500 z -500)
                       (create x -500 y 500 z 500)
                       (create x 500 y 500 z 500)
                       (create x 500 y 500 z -500)
                       (create x -500 y 500 z -500)))
        (needs-update t))
    (ctx translate (/ width 2) (/ height 2))
    (labels ((project ()
               (dolist (p points)
                 (with-slots (x y z) p
                   (let ((scale (/ fl (+ fl z center-z))))
                     (setf (@ p sx) (* x scale)
                           (@ p sy) (* y scale))))))
             (draw-line ()
               (let ((p (aref points (aref arguments 0))))
                 (ctx move-to (@ p sx) (@ p sy))
                 (loop for i from 1 to (1- (@ arguments length))
                       do (let ((p (aref points (aref arguments i))))
                            (ctx line-to (@ p sx) (@ p sy))))))
             (translate-model (x y z)
               (dolist (p points)
                 (incf (@ p x) x)
                 (incf (@ p y) y)
                 (incf (@ p z) z))
               (setf needs-update t))
             (rotate-x (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (y z) p
                     (setf y (- (* y cos) (* z sin))
                           z (+ (* z cos) (* y sin))))))
               (setf needs-update t))
             (rotate-y (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (x z) p
                     (setf x (- (* x cos) (* z sin))
                           z (+ (* z cos) (* x sin))))))
               (setf needs-update t))
             (rotate-z (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (x y) p
                     (setf x (- (* x cos) (* y sin))
                           y (+ (* y cos) (* x sin))))))
               (setf needs-update t)))
      (chain document body (add-event-listener
                            "keydown"
                            #'(lambda (evt)
                                (case (@ evt key-code)
                                  (37 (if (@ evt ctrl-key)
                                          (rotate-y 0.05)
                                          (translate-model -20 0 0)))
                                  (39 (if (@ evt ctrl-key)
                                          (rotate-y -0.05)
                                          (translate-model 20 0 0)))
                                  (38 (cond ((@ evt shift-key) (translate-model 0 0 20))
                                            ((@ evt ctrl-key) (rotate-x 0.05))
                                            (t (translate-model 0 -20 0))))
                                  (40 (cond ((@ evt shift-key) (translate-model 0 0 -20))
                                            ((@ evt ctrl-key) (rotate-x -0.05))
                                            (t (translate-model 0 20 0))))))))
      (def-animation-loop update
        (when needs-update
          (ctx clear-rect (/ width -2) (/ height -2) width height)
          (project)
          (ctx begin-path)
          (draw-line 0 1 2 3 0)
          (draw-line 4 5 6 7 4)
          (draw-line 0 4)
          (draw-line 1 5)
          (draw-line 2 6)
          (draw-line 3 7)
          (ctx stroke)
          (setf needs-update nil))))
    (update)))

(defun ep-27 ()
  "Easing and Tweening"
  (let ((target (make-vector width (* (random) height)))
        (position (make-vector 0 (* (random) height)))
        (ease 0.1))
    (chain document body (add-event-listener
                            "mousemove"
                            #'(lambda (evt)
                                (setf (@ target x) (@ evt client-x)
                                      (@ target y) (@ evt client-y)))))
    (def-animation-loop update ()
      (with-slots (x y) position
        (clear)
        (ctx begin-path)
        (ctx arc x y 10 0 (* pi 2) false)
        (ctx fill)
        (incf x (* (- (@ target x) x) ease))
        (incf y (* (- (@ target y) y) ease))))
    (update)))

(defun ep-28 ()
  "More on Easing"
  (let* ((target (make-vector width (* (random) height)))
         (num-points 100)
         (points (loop repeat num-points
                       collect (make-vector 0 0)))
        (ease 0.5))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf (@ target x) (@ evt client-x)
                                    (@ target y) (@ evt client-y)))))
    (labels ((ease-to (position target ease)
               (with-slots (x y) position
                 (incf x (* (- (@ target x) x) ease))
                 (incf y (* (- (@ target y) y) ease)))))
      (def-animation-loop update ()
        (clear)
        (let ((leader (make-vector (@ target x) (@ target y))))
          (loop for i from 1 to (1- num-points)
                do (let ((point (aref points i)))
                     (with-slots (x y) point
                       (ease-to point leader ease)
                       (ctx begin-path)
                       (ctx arc x y 10 0 (* pi 2) false)
                       (ctx fill)
                       (setf (@ leader x) x
                             (@ leader y) y)))))))
    (update)))

(defun ep-29 ()
  "Tweening Part I"
  (let ((start (create x 100 y 100))
        (target (create))
        (change (create))
        start-time
        (duration 1000))
    (labels ((draw-circle (x y)
               (ctx begin-path)
               (ctx arc x y 20 0 (* pi 2) false)
               (ctx fill))
             (linear-tween (k b c d)
               (+ (/ (* c k) d) b))
             (ease-in-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* c k k) b)))
             (ease-out-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* (- c) k (- k 2)) b)))
             (ease-in-out-quad (k b c d)
               (let ((k (/ k (/ d 2))))
                 (if (< k 1)
                     (+ (/ (* c k k) 2) b)
                     (+ (* (/ c -2) (1- (* (1- k) (- k 3)))) b)))))
      (with-slots ((start-x x) (start-y y)) start
        (draw-circle start-x start-y)
        (chain document body (add-event-listener
                              "click"
                              #'(lambda (evt)
                                  (setf (@ target x) (@ evt client-x)
                                        (@ target y) (@ evt client-y)
                                        (@ change x) (- (@ target x) start-x)
                                        (@ change y) (- (@ target y) start-y)
                                        start-time (new (*date)))
                                  (update))))
        (def-animation-loop update
          (clear)
          (let ((time (- (new (*date)) start-time)))
            (if (< time duration)
                (let ((x (ease-in-out-quad time start-x (@ change x) duration))
                      (y (ease-in-out-quad time start-y (@ change y) duration)))
                  (draw-circle x y))
                (progn
                  (draw-circle (@ target x) (@ target y))
                  (setf (@ start x) (@ target x)
                        (@ start y) (@ target y))))))))))

(defun ep-30 ()
  "Tweening Part II"
  (let ((ball (create x 100 y 100 alpha 1))
        (duration 1000))
    (labels ((draw-circle (x y)
               (ctx begin-path)
               (ctx arc x y 20 0 (* pi 2) false)
               (ctx fill))
             (linear-tween (k b c d)
               (+ (/ (* c k) d) b))
             (ease-in-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* c k k) b)))
             (ease-out-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* (- c) k (- k 2)) b)))
             (ease-in-out-quad (k b c d)
               (let ((k (/ k (/ d 2))))
                 (if (< k 1)
                     (+ (/ (* c k k) 2) b)
                     (+ (* (/ c -2) (1- (* (1- k) (- k 3)))) b))))
             (render ()
               (clear)
               (ctx begin-path)
               (setf (ctx-get global-alpha) (@ ball alpha))
               (ctx arc (@ ball x) (@ ball y) 20 0 (* pi 2) false)
               (ctx fill))
             (tween (obj props duration easing-func on-progress on-complete)
               (let* ((starts (create))
                      (changes (create))
                      (start-time (new (*date))))
                 (for-in (prop props)
                         (setf (getprop starts prop) (getprop obj prop)
                               (getprop changes prop) (- (getprop props prop)
                                                         (getprop starts prop))))
                 (labels ((update ()
                            (let ((time (- (new (*date)) start-time)))
                              (if (< time duration)
                                  (progn
                                    (for-in (prop props)
                                            (setf (getprop obj prop)
                                                  (easing-func time
                                                               (getprop starts prop)
                                                               (getprop changes prop)
                                                               duration)))
                                    (on-progress)
                                    (request-animation-frame update))
                                  (progn
                                    (setf time duration)
                                    (for-in (prop props)
                                            (setf (getprop obj prop)
                                                  (easing-func time
                                                               (getprop starts prop)
                                                               (getprop changes prop)
                                                               duration)))
                                    (on-complete))))))
                   (update))))
             (tween-back ()
               (tween ball (create x 100 y 100 alpha 1) 1000 ease-in-out-quad render render)))
      (tween ball (create x 900 y 700 alpha 0) 1000 ease-in-out-quad render tween-back))))

(defun ep-31 ()
  "Tweening Part III")

(defun ep-32 ()
  "Line Intersections Part I"
  (labels ((line-intersect (p0 p1 p2 p3)
             (let* ((a1 (- (@ p1 y) (@ p0 y)))
                    (b1 (- (@ p0 x) (@ p1 x)))
                    (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                    (a2 (- (@ p3 y) (@ p2 y)))
                    (b2 (- (@ p2 x) (@ p3 x)))
                    (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                    (denominator (- (* a1 b2) (* a2 b1))))
               (create x (/ (- (* b2 c1) (* b1 c2)) denominator)
                       y (/ (- (* a1 c2) (* a2 c1)) denominator)))))
    (let* ((p0 (create x 100 y 100))
           (p1 (create x 500 y 500))
           (p2 (create x 600 y 50))
           (p3 (create x 80 y 600))
           (intersect (line-intersect p0 p1 p2 p3)))
      (ctx begin-path)
      (ctx move-to (@ p0 x) (@ p0 y))
      (ctx line-to (@ p1 x) (@ p1 y))
      (ctx move-to (@ p2 x) (@ p2 y))
      (ctx line-to (@ p3 x) (@ p3 y))
      (ctx stroke)
      (ctx begin-path)
      (ctx arc (@ intersect x) (@ intersect y) 20 0 (* pi 2) false)
      (ctx stroke))))

(defun ep-33 ()
  "Line Intersections Part II"
  (let* ((p0 (create x 100 y 100))
         (p1 (create x 500 y 500))
         (p2 (create x 600 y 50))
         (p3 (create x 80 y 600))
         click-point)
    (labels ((line-intersect (p0 p1 p2 p3)
             (let* ((a1 (- (@ p1 y) (@ p0 y)))
                    (b1 (- (@ p0 x) (@ p1 x)))
                    (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                    (a2 (- (@ p3 y) (@ p2 y)))
                    (b2 (- (@ p2 x) (@ p3 x)))
                    (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                    (denominator (- (* a1 b2) (* a2 b1))))
               (if (= denominator 0)
                   nil
                   (create x (/ (- (* b2 c1) (* b1 c2)) denominator)
                           y (/ (- (* a1 c2) (* a2 c1)) denominator)))))
             (segment-intersect (p0 p1 p2 p3)
               (let* ((a1 (- (@ p1 y) (@ p0 y)))
                      (b1 (- (@ p0 x) (@ p1 x)))
                      (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                      (a2 (- (@ p3 y) (@ p2 y)))
                      (b2 (- (@ p2 x) (@ p3 x)))
                      (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                      (denominator (- (* a1 b2) (* a2 b1))))
                 (if (= denominator 0)
                     nil
                     (let* ((intersect-x (/ (- (* b2 c1) (* b1 c2)) denominator))
                            (intersect-y (/ (- (* a1 c2) (* a2 c1)) denominator))
                            (rx0 (/ (- intersect-x (@ p0 x)) (- (@ p1 x) (@ p0 x))))
                            (ry0 (/ (- intersect-y (@ p0 y)) (- (@ p1 y) (@ p0 y))))
                            (rx1 (/ (- intersect-x (@ p2 x)) (- (@ p3 x) (@ p2 x))))
                            (ry1 (/ (- intersect-y (@ p2 y)) (- (@ p3 y) (@ p2 y)))))
                       (if (and (or (and (>= rx0 0) (<= rx0 1))
                                    (and (>= ry0 0) (<= ry0 1)))
                                (or (and (>= rx1 0) (<= rx1 1))
                                    (and (>= ry1 0) (<= ry1 1))))
                           (create x intersect-x y intersect-y)
                           nil)))))
             (get-click-point (x y)
               (let ((points (array p0 p1 p2 p3)))
                 (dolist (p points)
                   (let* ((dx (- (@ p x) x))
                          (dy (- (@ p y) y))
                          (dist (sqrt (+ (* dx dx) (* dy dy)))))
                     (when (< dist 10)
                       (return p))))))
             (on-mouse-down (evt)
               (setf click-point (get-click-point (@ evt client-x) (@ evt client-y)))
               (when click-point
                 (chain document body (add-event-listener "mousemove" on-mouse-move))
                 (chain document body (add-event-listener "mouseup" on-mouse-up))))
             (on-mouse-move (evt)
               (setf (@ click-point x) (@ evt client-x)
                     (@ click-point y) (@ evt client-y))
               (render))
             (on-mouse-up(evt)
               (chain document body (remove-event-listener "mousemove" on-mouse-move))
               (chain document body (remove-event-listener "mouseup" on-mouse-up)))
             (draw-point (p)
               (ctx begin-path)
               (ctx arc (@ p x) (@ p y) 10 0 (* pi 2) false)
               (ctx fill))
             (render ()
               (clear)
               (draw-point p0)
               (draw-point p1)
               (draw-point p2)
               (draw-point p3)
               (ctx begin-path)
               (ctx move-to (@ p0 x) (@ p0 y))
               (ctx line-to (@ p1 x) (@ p1 y))
               (ctx move-to (@ p2 x) (@ p2 y))
               (ctx line-to (@ p3 x) (@ p3 y))
               (ctx stroke)
               (let ((intersect (segment-intersect p0 p1 p2 p3)))
                 (when intersect
                   (ctx begin-path)
                   (ctx arc (@ intersect x) (@ intersect y) 20 0 (* pi 2) false)
                   (ctx stroke)))))
      (chain document body (add-event-listener "mousedown" on-mouse-down))
      (render))))

(defun ep-34 ()
  "Line Intersections Part III"
  (let ((star0 (create x 200
                       y 200
                       points (array (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0))
                       offset (array (create x 100 y 0)
                                     (create x 40 y 29)
                                     (create x 31 y 95)
                                     (create x -15 y 48)
                                     (create x -81 y 59)
                                     (create x -50 y 0)
                                     (create x -81 y -59)
                                     (create x -15 y -48)
                                     (create x 31 y -95)
                                     (create x 40 y -29))))
        (star1 (create x 600
                       y 500
                       points (array (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0))
                       offset (array (create x 100 y 0)
                                     (create x 40 y 29)
                                     (create x 31 y 95)
                                     (create x -15 y 48)
                                     (create x -81 y 59)
                                     (create x -50 y 0)
                                     (create x -81 y -59)
                                     (create x -15 y -48)
                                     (create x 31 y -95)
                                     (create x 40 y -29)))))
    (labels ((update-star (star)
               (with-slots (x y points offset) star
                 (dotimes (i (@ points length))
                   (setf (@ (aref points i) x) (+ x (@ (aref offset i) x))
                         (@ (aref points i) y) (+ y (@ (aref offset i) y))))))
             (draw-star (star)
               (with-slots (points) star
                 (ctx begin-path)
                 (ctx move-to (@ (aref points 0) x) (@ (aref points 0) y))
                 (dolist (p (chain points (slice 1)))
                   (ctx line-to (@ p x) (@ p y)))
                 (ctx close-path)
                 (ctx fill)))
             (segment-intersect (p0 p1 p2 p3)
               (let* ((a1 (- (@ p1 y) (@ p0 y)))
                      (b1 (- (@ p0 x) (@ p1 x)))
                      (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                      (a2 (- (@ p3 y) (@ p2 y)))
                      (b2 (- (@ p2 x) (@ p3 x)))
                      (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                      (denominator (- (* a1 b2) (* a2 b1))))
                 (if (= denominator 0)
                     nil
                     (let* ((intersect-x (/ (- (* b2 c1) (* b1 c2)) denominator))
                            (intersect-y (/ (- (* a1 c2) (* a2 c1)) denominator))
                            (rx0 (/ (- intersect-x (@ p0 x)) (- (@ p1 x) (@ p0 x))))
                            (ry0 (/ (- intersect-y (@ p0 y)) (- (@ p1 y) (@ p0 y))))
                            (rx1 (/ (- intersect-x (@ p2 x)) (- (@ p3 x) (@ p2 x))))
                            (ry1 (/ (- intersect-y (@ p2 y)) (- (@ p3 y) (@ p2 y)))))
                       (if (and (or (and (>= rx0 0) (<= rx0 1))
                                    (and (>= ry0 0) (<= ry0 1)))
                                (or (and (>= rx1 0) (<= rx1 1))
                                    (and (>= ry1 0) (<= ry1 1))))
                           (create x intersect-x y intersect-y)
                           nil)))))
             (check-star-collision (star-a star-b)
               (let ((num-points (@ star-a points length)))
                 (dotimes (i num-points)
                   (let ((p0 (aref (@ star-a points) i))
                         (p1 (aref (@ star-a points) (mod (1+ i) num-points))))
                     (dotimes (j num-points)
                       (let ((p2 (aref (@ star-b points) j))
                             (p3 (aref (@ star-b points) (mod (1+ j) num-points))))
                         (when (segment-intersect p0 p1 p2 p3)
                           (return-from check-star-collision t)))))))
               false))
      (chain document body (add-event-listener
                            "mousemove"
                            #'(lambda (evt)
                                (clear)
                                (setf (@ star0 x) (@ evt client-x)
                                      (@ star0 y) (@ evt client-y))
                                (update-star star0)
                                (update-star star1)
                                (setf (ctx-get fill-style)
                                      (if (check-star-collision star0 star1)
                                          "red"
                                          "black"))
                                (draw-star star0)
                                (draw-star star1)))))))

(defun ep-35 ()
  "Intro to Fractals"
  (labels ((draw-triangle (p0 p1 p2)
             (ctx move-to (@ p0 x) (@ p0 y))
             (ctx line-to (@ p1 x) (@ p1 y))
             (ctx line-to (@ p2 x) (@ p2 y))
             (ctx fill))
           (sierpinski (p0 p1 p2 limit)
             (if (> limit 0)
                 (let ((p-a (create x (/ (+ (@ p0 x) (@ p1 x)) 2)
                                    y (/ (+ (@ p0 y) (@ p1 y)) 2)))
                       (p-b (create x (/ (+ (@ p1 x) (@ p2 x)) 2)
                                    y (/ (+ (@ p1 y) (@ p2 y)) 2)))
                       (p-c (create x (/ (+ (@ p2 x) (@ p0 x)) 2)
                                    y (/ (+ (@ p2 y) (@ p0 y)) 2))))
                   (sierpinski p0 p-a p-c (1- limit))
                   (sierpinski p-a p1 p-b (1- limit))
                   (sierpinski p-c p-b p2 (1- limit)))
                 (draw-triangle p0 p1 p2)))
           (koch (p0 p1 limit)
             (let* ((dx (- (@ p1 x) (@ p0 x)))
                    (dy (- (@ p1 y) (@ p0 y)))
                    (dist (sqrt (+ (* dx dx) (* dy dy))))
                    (unit (/ dist 3))
                    (angle (chain *math (atan2 dy dx)))
                    (p-a (create x (+ (@ p0 x) (/ dx 3))
                                 y (+ (@ p0 y) (/ dy 3))))
                    (p-c (create x (- (@ p1 x) (/ dx 3))
                                 y (- (@ p1 y) (/ dy 3))))
                    (p-b (create x (+ (@ p-a x) (* (cos (- angle (/ pi 3))) unit))
                                 y (+ (@ p-a y) (* (sin (- angle (/ pi 3))) unit)))))
               (if (> limit 0)
                   (progn
                     (koch p0 p-a (1- limit))
                     (koch p-a p-b (1- limit))
                     (koch p-b p-c (1- limit))
                     (koch p-c p-1 (1- limit)))
                   (progn
                     (ctx begin-path)
                     (ctx move-to (@ p0 x) (@ p0 y))
                     (ctx line-to (@ p-a x) (@ p-a y))
                     (ctx line-to (@ p-b x) (@ p-b y))
                     (ctx line-to (@ p-c x) (@ p-c y))
                     (ctx line-to (@ p-1 x) (@ p-1 y))
                     (ctx stroke))))))
    (let ((p0 (create x 0 y -321))
          (p1 (create x 278 y 160))
          (p2 (create x -278 y 160)))
      (ctx translate (/ width 2) (/ height 2))
      ;; (sierpinski p0 p1 p2 3)
      (koch p0 p1 5)
      (koch p1 p2 5)
      (koch p2 p0 5))))

(defun ep-36 ()
  "Verlet Integration Part I"
  (let ((points (array (create x 100 y 100 oldx 95 oldy 95)))
        (bounce 0.9)
        (gravity 0.5)
        (friction 0.999))
    (labels ((update-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (setf oldx x
                           oldy y
                           x (+ x vx)
                           y (+ y vy gravity))
                     (when (> x width)
                       (setf x width
                             oldx (+ x (* vx bounce))))
                     (when (< x 0)
                       (setf x 0
                             oldx (+ x (* vx bounce))))
                     (when (> y height)
                       (setf y height
                             oldy (+ y (* vy bounce))))
                     (when (< y 0)
                       (setf y 0
                             oldy (+ y (* vy bounce))))))))
             (render-points ()
               (clear)
               (dolist (p points)
                 (with-slots (x y) p
                   (ctx begin-path)
                   (ctx arc x y 5 0 (* pi 2))
                   (ctx fill)))))
      (def-animation-loop update ()
        (update-points)
        (render-points))
      (update))))

(defun ep-37 ()
  "Verlet Integration Part II"
  (let* ((points (array (create x 100 y 100 oldx 85 oldy 95)
                        (create x 200 y 100 oldx 200 oldy 100)
                        (create x 200 y 200 oldx 200 oldy 200)
                        (create x 100 y 200 oldx 100 oldy 200)))
         (sticks (array))
         (bounce 0.9)
         (gravity 0.5)
         (friction 0.999))
    (labels ((update-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (setf oldx x
                           oldy y
                           x (+ x vx)
                           y (+ y vy gravity))))))
             (constraint-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (when (> x width)
                       (setf x width
                             oldx (+ x (* vx bounce))))
                     (when (< x 0)
                       (setf x 0
                             oldx (+ x (* vx bounce))))
                     (when (> y height)
                       (setf y height
                             oldy (+ y (* vy bounce))))
                     (when (< y 0)
                       (setf y 0
                             oldy (+ y (* vy bounce))))))))
             (update-sticks ()
               (dolist (s sticks)
                 (with-slots (p0 p1) s
                   (let* ((dx (- (@ p1 x) (@ p0 x)))
                          (dy (- (@ p1 y) (@ p0 y)))
                          (dist (sqrt (+ (* dx dx) (* dy dy))))
                          (diff (- (@ s length) dist))
                          (percent (/ diff dist 2))
                          (offset-x (* dx percent))
                          (offset-y (* dy percent)))
                     (decf (@ p0 x) offset-x)
                     (decf (@ p0 y) offset-y)
                     (incf (@ p1 x) offset-x)
                     (incf (@ p1 y) offset-y)))))
             (render-points ()
               (clear)
               (dolist (p points)
                 (with-slots (x y) p
                   (ctx begin-path)
                   (ctx arc x y 5 0 (* pi 2))
                   (ctx fill))))
             (render-sticks ()
               (ctx begin-path)
               (dolist (s sticks)
                 (with-slots (p0 p1) s
                   (ctx move-to (@ p0 x) (@ p0 y))
                   (ctx line-to (@ p1 x) (@ p1 y))))
               (ctx stroke)))
      (let ((p0 (aref points 0))
            (p1 (aref points 1))
            (p2 (aref points 2))
            (p3 (aref points 3)))
        (chain sticks (push (create p0 p0 p1 p1 length (distance p0 p1))))
        (chain sticks (push (create p0 p1 p1 p2 length (distance p1 p2))))
        (chain sticks (push (create p0 p2 p1 p3 length (distance p2 p3))))
        (chain sticks (push (create p0 p3 p1 p0 length (distance p3 p0))))
        (chain sticks (push (create p0 p0 p1 p2 length (distance p0 p2)))))
      (def-animation-loop update
        (update-points)
        (loop repeat 3
              do (progn
                   (update-sticks)
                   (constraint-points)))
        (render-points)
        (render-sticks))
      (update))))

(defun ep-38 ()
  "Verlet Integration Part III"
  (let* ((points (array (create x 100
                                y 100
                                oldx (+ 50 (* (random) 100))
                                oldy (+ 50 (* (random) 100)))
                        (create x 420 y 100 oldx 420 oldy 100)
                        (create x 420 y 340 oldx 420 oldy 340)
                        (create x 100 y 340 oldx 100 oldy 340)))
         (sticks (array))
         (forms (array))
         (images (array))
         (bounce 0.9)
         (gravity 0.5)
         (friction 0.999))
    (labels ((update-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (setf oldx x
                           oldy y
                           x (+ x vx)
                           y (+ y vy gravity))))))
             (constraint-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (when (> x width)
                       (setf x width
                             oldx (+ x (* vx bounce))))
                     (when (< x 0)
                       (setf x 0
                             oldx (+ x (* vx bounce))))
                     (when (> y height)
                       (setf y height
                             oldy (+ y (* vy bounce))))
                     (when (< y 0)
                       (setf y 0
                             oldy (+ y (* vy bounce))))))))
             (update-sticks ()
               (dolist (s sticks)
                 (with-slots (p0 p1) s
                   (let* ((dx (- (@ p1 x) (@ p0 x)))
                          (dy (- (@ p1 y) (@ p0 y)))
                          (dist (sqrt (+ (* dx dx) (* dy dy))))
                          (diff (- (@ s length) dist))
                          (percent (/ diff dist 2))
                          (offset-x (* dx percent))
                          (offset-y (* dy percent)))
                     (decf (@ p0 x) offset-x)
                     (decf (@ p0 y) offset-y)
                     (incf (@ p1 x) offset-x)
                     (incf (@ p1 y) offset-y)))))
             (render-points ()
               (dolist (p points)
                 (with-slots (x y) p
                   (ctx begin-path)
                   (ctx arc x y 5 0 (* pi 2))
                   (ctx fill))))
             (render-sticks ()
               (dolist (s sticks)
                 (with-slots (p0 p1 hidden color width) s
                   (unless hidden
                     (ctx begin-path)
                     (setf (ctx-get stroke-style) (if color color "black")
                           (ctx-get line-width) (if width width 1))
                     (ctx move-to (@ p0 x) (@ p0 y))
                     (ctx line-to (@ p1 x) (@ p1 y))
                     (ctx stroke)))))
             (render-forms ()
               (dolist (form forms)
                 (with-slots (path color) form
                   (ctx begin-path)
                   (setf (ctx-get fill-style) color)
                   (ctx move-to (@ (aref path 0) x) (@ (aref path 0) y))
                   (loop for i from 1 to (1- (@ path length))
                         do (ctx line-to (@ (aref path i) x) (@ (aref path i) y)))
                   (ctx fill))))
             (render-images ()
               (dolist (img images)
                 (let* ((p0 (aref (@ img path) 0))
                        (p1 (aref (@ img path) 1))
                        (p3 (aref (@ img path) 3))
                        (w (distance p0 p1))
                        (h (distance p0 p3))
                        (dx (- (@ p1 x) (@ p0 x)))
                        (dy (- (@ p1 y) (@ p0 y)))
                        (angle (chain *math (atan2 dy dx))))
                   (with-context
                     (ctx translate (@ p0 x) (@ p0 y))
                     (ctx rotate angle)
                     (ctx draw-image (@ img img) 0 0 w h)))))
             (load-image (url)
               (let ((img (chain document (create-element "img"))))
                 (setf (@ img src) url)
                 img)))
      (let ((p0 (aref points 0))
            (p1 (aref points 1))
            (p2 (aref points 2))
            (p3 (aref points 3)))
        (chain sticks (push (create p0 p0
                                    p1 p1
                                    length (distance p0 p1)
                                    color "red"
                                    width 5)))
        (chain sticks (push (create p0 p1 p1 p2 length (distance p1 p2))))
        (chain sticks (push (create p0 p2 p1 p3 length (distance p2 p3))))
        (chain sticks (push (create p0 p3 p1 p0 length (distance p3 p0))))
        (chain sticks (push (create p0 p0 p1 p2 length (distance p0 p2) hidden t)))
        (chain forms (push (create path (array p0 p1 p2 p3)
                                   color "green")))
        (chain images (push (create path (array p0 p1 p2 p3)
                                    img (load-image "https://picsum.photos/id/1074/320/240")))))
      (def-animation-loop update
        (update-points)
        (loop repeat 3
              do (progn
                   (update-sticks)
                   (constraint-points)))
        (clear)
        ;; (render-forms)
        (render-images))
      (update))))

(defun ep-39 ()
  "Verlet Integration Part IV"
  (let* ((points (array (create x 100
                                y 100
                                oldx (+ 75 (* (random) 50))
                                oldy (+ 75 (* (random) 50)))
                        (create x 200 y 100 oldx 200 oldy 100)
                        (create x 200 y 200 oldx 200 oldy 200)
                        (create x 100 y 200 oldx 100 oldy 200)
                        (create x 400 y 100 oldx 400 oldy 100)
                        (create x 250 y 100 oldx 250 oldy 100)))
         (sticks (array))
         (bounce 0.9)
         (gravity 0.5)
         (friction 0.999)
         (engine (create base-x 450
                         base-y 100
                         range 100
                         angle 0
                         speed 0.05
                         x 550
                         y 100
                         pinned t)))
    (labels ((update-engine ()
               (with-slots (x y base-x base-y angle speed range) engine
                 (setf x (+ base-x (* (cos angle) range))
                       y (+ base-y (* (sin angle) range))
                       angle (+ angle speed))))
             (update-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy pinned) p
                   (unless pinned
                     (let ((vx (* (- x oldx) friction))
                           (vy (* (- y oldy) friction)))
                       (setf oldx x
                             oldy y
                             x (+ x vx)
                             y (+ y vy gravity)))))))
             (constraint-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy pinned) p
                   (unless pinned
                     (let ((vx (* (- x oldx) friction))
                           (vy (* (- y oldy) friction)))
                       (when (> x width)
                         (setf x width
                               oldx (+ x (* vx bounce))))
                       (when (< x 0)
                         (setf x 0
                               oldx (+ x (* vx bounce))))
                       (when (> y height)
                         (setf y height
                               oldy (+ y (* vy bounce))))
                       (when (< y 0)
                         (setf y 0
                               oldy (+ y (* vy bounce)))))))))
             (update-sticks ()
               (dolist (s sticks)
                 (with-slots (p0 p1) s
                   (let* ((dx (- (@ p1 x) (@ p0 x)))
                          (dy (- (@ p1 y) (@ p0 y)))
                          (dist (sqrt (+ (* dx dx) (* dy dy))))
                          (diff (- (@ s length) dist))
                          (percent (/ diff dist 2))
                          (offset-x (* dx percent))
                          (offset-y (* dy percent)))
                     (unless (@ p0 pinned)
                       (decf (@ p0 x) offset-x)
                       (decf (@ p0 y) offset-y))
                     (unless (@ p1 pinned)
                       (incf (@ p1 x) offset-x)
                       (incf (@ p1 y) offset-y))))))
             (render-points ()
               (clear)
               (dolist (p points)
                 (with-slots (x y) p
                   (ctx begin-path)
                   (ctx arc x y 5 0 (* pi 2))
                   (ctx fill))))
             (render-sticks ()
               (ctx begin-path)
               (dolist (s sticks)
                 (with-slots (p0 p1) s
                   (ctx move-to (@ p0 x) (@ p0 y))
                   (ctx line-to (@ p1 x) (@ p1 y))))
               (ctx stroke))
             (render-engine ()
               (with-slots (x y base-x base-y range) engine
                 (ctx begin-path)
                 (ctx arc base-x base-y range 0 (* pi 2))
                 (ctx stroke)
                 (ctx begin-path)
                 (ctx arc x y 5 0 (* pi 2))
                 (ctx fill))))
      (let ((p0 (aref points 0))
            (p1 (aref points 1))
            (p2 (aref points 2))
            (p3 (aref points 3))
            (p4 (aref points 4))
            (p5 (aref points 5)))
        (chain sticks (push (create p0 p0 p1 p1 length (distance p0 p1))))
        (chain sticks (push (create p0 p1 p1 p2 length (distance p1 p2))))
        (chain sticks (push (create p0 p2 p1 p3 length (distance p2 p3))))
        (chain sticks (push (create p0 p3 p1 p0 length (distance p3 p0))))
        (chain sticks (push (create p0 p0 p1 p2 length (distance p0 p2))))
        (chain sticks (push (create p0 engine p1 p4 length (distance engine p4))))
        (chain sticks (push (create p0 p4 p1 p5 length (distance p4 p5))))
        (chain sticks (push (create p0 p5 p1 p0 length (distance p5 p0)))))
      (def-animation-loop update
        (update-engine)
        (update-points)
        (loop repeat 3
              do (progn
                   (update-sticks)
                   (constraint-points)))
        (render-points)
        (render-sticks)
        (render-engine))
      (update))))

(defun ep-40 ()
  "Fractal Trees"
  (let ((branch-angle-a (random-range 0 (/ pi -2))))
    (labels ((tree (x y size angle limit)
               (with-context
                 (ctx translate x y)
                 (ctx rotate angle)
                 (ctx fill-rect 0 0 size (- size))
                 (let ((x0 0)
                       (y0 (- size))
                       (size0 (abs (* (cos branch-angle-a) size)))
                       (angle0 branch-angle-a))
                   (if (> limit 0)
                       (tree x0 y0 size0 angle0 (- limit 1))
                       (progn
                         (with-context
                           (ctx translate x0 y0)
                           (ctx rotate angle0)
                           (ctx fill-rect 0 0 size0 (- size0)))))
                   (let ((x1 (+ x0 (* (cos angle0) size0)))
                         (y1 (+ y0 (* (sin angle0) size0)))
                         (size1 (abs (* (sin branch-angle-a) size)))
                         (angle1 (+ angle0 (/ pi 2))))
                     (if (> limit 0)
                         (tree x1 y1 size1 angle1 (- limit 1))
                         (progn
                           (with-context
                             (ctx translate x1 y1)
                             (ctx rotate angle1)
                             (ctx fill-rect 0 0 size1 (- size1))))))))))
      (tree (- (/ width 2) 75) height 150 0 8))))

(defun ep-41 ()
  "Isometric 3D Part I"
  (let ((tile-width 100)
        (tile-height 50))
    (labels ((draw-tile (x y color)
               (with-context
                 (ctx translate (* (- x y) (/ tile-width 2)) (* (+ x y) (/ tile-height 2)))
                 (ctx begin-path)
                 (ctx move-to 0 0)
                 (ctx line-to (/ tile-width 2) (/ tile-height 2))
                 (ctx line-to 0 tile-height)
                 (ctx line-to (/ tile-width -2) (/ tile-height 2))
                 (ctx close-path)
                 (setf (ctx-get fill-style) color)
                 (ctx fill)))
             (draw-block (x y z)
               (let ((top "#eeeeee")
                     (right "#cccccc")
                     (left "#999999"))
                 (with-context
                   (ctx translate (* (- x y) (/ tile-width 2)) (* (+ x y) (/ tile-height 2)))
                   (ctx begin-path)
                   (ctx move-to 0 (- (* z tile-height)))
                   (ctx line-to (/ tile-width 2) (- (/ tile-height 2) (* z tile-height)))
                   (ctx line-to 0 (- tile-height (* z tile-height)))
                   (ctx line-to (/ tile-width -2) (- (/ tile-height 2) (* z tile-height)))
                   (ctx close-path)
                   (setf (ctx-get fill-style) top)
                   (ctx fill)

                   (ctx begin-path)
                   (ctx move-to (/ tile-width -2) (- (/ tile-height 2) (* z tile-height)))
                   (ctx line-to 0 (- tile-height (* z tile-height)))
                   (ctx line-to 0 tile-height)
                   (ctx line-to (/ tile-width -2) (/ tile-height 2))
                   (ctx close-path)
                   (setf (ctx-get fill-style) left)
                   (ctx fill)

                   (ctx begin-path)
                   (ctx move-to (/ tile-width 2) (- (/ tile-height 2) (* z tile-height)))
                   (ctx line-to 0 (- tile-height (* z tile-height)))
                   (ctx line-to 0 tile-height)
                   (ctx line-to (/ tile-width 2) (/ tile-height 2))
                   (ctx close-path)
                   (setf (ctx-get fill-style) right)
                   (ctx fill)
)))
             (random-color ()
               (let ((r (random-int 0 255))
                     (g (random-int 0 255))
                     (b (random-int 0 255)))
                 (stringify "rgb(" r "," g "," b ")")))))
    (ctx translate (/ width 2) 200)
    (dotimes (x 10)
      (dotimes (y 10)
        ;; (draw-tile x y (random-color))
        (draw-block x y (random-int 0 4))))))

(defun ep-42 ()
  "Isometric 3D Part II"
  (let* ((character-canvas (chain document (create-element "canvas")))
         (character-ctx (chain character-canvas (get-context "2d")))
         (tile-width 100)
         (tile-height 50)
         (char-x 0.5)
         (char-y 9.5)
         (grid (array ; blue = 0, red = 1, yellow = 2
                (array 1 1 1 1 1 1 0 0 0 0)
                (array 1 1 1 1 1 1 0 0 0 0)
                (array 1 1 1 1 1 0 0 0 0 0)
                (array 1 1 1 2 0 0 0 0 0 0)
                (array 1 1 2 2 0 0 0 0 0 0)
                (array 1 2 2 2 0 0 0 0 0 0)
                (array 2 2 2 2 0 0 0 0 0 0)
                (array 2 2 2 0 0 0 0 0 0 0)
                (array 2 2 2 0 0 0 0 0 0 0)
                (array 2 2 2 2 2 2 2 2 2 0))))
    (setf (@ character-canvas id) "character-canvas"
          (@ character-canvas width) width
          (@ character-canvas height) height)
    (chain document body (append-child character-canvas))
    (dolist (el (chain document (query-selector-all "canvas")))
      (with-slots (display position top left) (@ el style)
        (setf display "block"
              position "absolute"
              top "0px"
              left "0px")))
    (labels ((draw-tile (x y color)
               (with-context
                 (ctx translate (* (- x y) (/ tile-width 2)) (* (+ x y) (/ tile-height 2)))
                 (ctx begin-path)
                 (ctx move-to 0 0)
                 (ctx line-to (/ tile-width 2) (/ tile-height 2))
                 (ctx line-to 0 tile-height)
                 (ctx line-to (/ tile-width -2) (/ tile-height 2))
                 (ctx close-path)
                 (setf (ctx-get fill-style)
                       (case color
                         (0 "blue")
                         (1 "red")
                         (2 "yellow")))
                 (ctx fill)))
             (draw-character (x y)
               (chain character-ctx (clear-rect (/ width -2) -50 width height))
               (chain character-ctx (save))
               (chain character-ctx (translate (* (- x y) (/ tile-width 2)) (* (+ x y) (/ tile-height 2))))
               (chain character-ctx (begin-path))
               (chain character-ctx (arc 0 0 10 0 (* pi 2) false))
               (chain character-ctx (fill))
               (chain character-ctx (restore)))
             (can-move (x y)
               (setf x (floor x)
                     y (floor y))
               (and (< -1 y (@ grid length))
                    (< -1 x (@ (aref grid y) length))
                    (not (= (aref grid y x) 0))))
             (move-character (evt)
               (case (@ evt key-code)
                 (37 (when (can-move (1- char-x) char-y)
                       (decf char-x)))
                 (38 (when (can-move char-x (1- char-y))
                       (decf char-y)))
                 (39 (when (can-move (1+ char-x) char-y)
                       (incf char-x)))
                 (40 (when (can-move char-x (1+ char-y))
                       (incf char-y))))
               (draw-character char-x char-y))))
    (ctx translate (/ width 2) 200)
    (chain character-ctx (translate (/ width 2) 200))
    (chain document (add-event-listener "keydown" #'move-character))
    (dotimes (x 10)
      (dotimes (y 10)
        (draw-tile x y (aref grid y x))))
    (draw-character char-x char-y)))

(defun ep-43 ()
  "Kinematics Part I"
  (let* ((arm (make-arm 100 0 0 0))
         (arm2 (make-arm 100 0 0 0))
         (arm3 (make-arm 100 0 0 0))
         (angle 0))
    (with-slots (x y length angle) arm
      (setf x (/ width 2) y (/ height 2) angle 0))
    (with-slots (x y length angle parent) arm2
      (setf x (arm-end-x arm) y (arm-end-y arm) angle 1.3 parent arm))
    (with-slots (x y length angle parent) arm3
      (setf x (arm-end-x arm2) y (arm-end-y arm2) angle 1.3 parent arm2))
    (def-animation-loop update
      (clear)
      (setf (@ arm angle) (* (sin angle) 1.2)
            (@ arm2 angle) (* (cos (* angle 0.5)) 0.92)
            (@ arm3 angle) (* (sin (* angle 1.5)) 1.34)
            (@ arm2 x) (arm-end-x arm)
            (@ arm2 y) (arm-end-y arm)
            (@ arm3 x) (arm-end-x arm2)
            (@ arm3 y) (arm-end-y arm2))
      (incf angle 0.05)
      (render-arm arm)
      (render-arm arm2)
      (render-arm arm3))
    (update)))

(defun ep-44 ()
  "Kinematics Part II"
  (let ((leg0 (make-fk-system (/ width 2) (/ height 2)))
        (leg1 (make-fk-system (/ width 2) (/ height 2))))
    (setf (@ leg1 phase) pi)
    (fk-system-add-arm! leg0 200 (/ pi 2) (/ pi 4) 0)
    (fk-system-add-arm! leg0 180 0.87 0.87 -1.5)
    (fk-system-add-arm! leg1 200 (/ pi 2) (/ pi 4) 0)
    (fk-system-add-arm! leg1 180 0.87 0.87 -1.5)
    (def-animation-loop update
      (clear)
      (fk-system-update! leg0)
      (render-fk-system leg0)
      (fk-system-update! leg1)
      (render-fk-system leg1))
    (update)))

(defun ep-45 ()
  "Kinematics Part III"
  (let* ((ik-system (make-ik-system (/ width 2) (/ height 2))))
    (dotimes (_ 20)
      (ik-system-add-arm! ik-system 30))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (drag-arm (@ ik-system last-arm) (@ evt client-x) (@ evt client-y)))))
    (def-animation-loop update
      (clear)
      (render-ik-system ik-system))
    (update)))

(defun ep-46 ()
  "Kinematics Part IV"
  (let* ((ik-system1 (make-ik-system 250 height))
         (ik-system2 (make-ik-system (- width 250) height))
         (ball (make-particle 100 100 5 0 0.25)))
    (setf (particle-radius ball) 20)
    (ik-system-add-arm! ik-system1 240)
    (ik-system-add-arm! ik-system1 180)
    (ik-system-add-arm! ik-system1 120)
    (ik-system-add-arm! ik-system2 240)
    (ik-system-add-arm! ik-system2 180)
    (ik-system-add-arm! ik-system2 120)
    (def-animation-loop update
      (clear)
      (particle-update! ball)
      (draw-particle ball)
      (bounce ball)
      (ik-system-reach ik-system1 (particle-x ball) (particle-y ball))
      (ik-system-reach ik-system2 (particle-x ball) (particle-y ball))
      (render-ik-system ik-system1)
      (render-ik-system ik-system2))
    (update)))

(defun ep-47 ()
  "Weighted Random"
  (let ((prizes (array
                 (create prize "nothing!" chance 8)
                 (create prize "a gold piece" chance 5)
                 (create prize "a treasure chest" chance 2)
                 (create prize "poison" chance 1)
                 (create prize "food" chance 3))))
    (labels ((get-prize ()
               (let* ((total (chain prizes (reduce #'(lambda (acc cur)
                                                       (+ acc (@ cur chance))) 0)))
                      (rand (* (random) total)))
                 (dolist (prize prizes)
                   (if (< rand (@ prize chance))
                       (return (@ prize prize))
                       (decf rand (@ prize chance))))))))
    (chain document body
           (add-event-listener "click"
                               #'(lambda ()
                                   (chain console (log (stringify "You won " (get-prize)))))))))

(defun ep-48 ()
  "Matrix Math Part I")

(defun ep-49 ()
  "Matrix Math Part II"
  (let* ((angle (/ pi 4))
         (cos (cos angle))
         (sin (sin angle))
         (sx 2)
         (sy 1))
    (ctx set-transform (* cos sx) (* sin sy) (* (- sin) sx) (* cos sy) 500 100)
    (ctx fill-rect 0 0 100 100)
    (ctx set-transform (* cos sx) (* sin sx) (* (- sin) sy) (* cos sy) 500 300)
    (ctx fill-rect 0 0 100 100)))

(defun ep-50 ()
  "IFS Fractals"
  (let ((rules (array
                (create a 0.85 b 0.04 c -0.04 d 0.85
                        tx 0 ty 1.6
                        weight 0.85 color "red")
                (create a -0.15 b 0.28 c 0.26 d 0.24
                        tx 0 ty 0.44
                        weight 0.07 color "green")
                (create a 0.2 b -0.26 c 0.23 d
                        0.22 tx 0 ty 1.6
                        weight 0.07 color "blue")
                (create a 0 b 0 c 0 d 0.16
                        tx 0 ty 0
                        weight 0.01 color "yellow")))
        (x (random))
        (y (random)))
    (labels ((get-rule ()
               (let ((rand (random)))
                 (dolist (rule rules)
                   (when (< rand (@ rule weight))
                     (return rule))
                   (decf rand (@ rule weight)))))
             (plot (x y color)
               (setf (ctx-get fill-style) color)
               (ctx fill-rect (* x 50) (* y -50) 0.5 0.5)))
      (def-animation-loop iterate
        (dotimes (_ 100)
          (let ((rule (get-rule)))
            (with-slots (a b c d tx ty color) rule
              (let ((x1 (+ (* x a) (* y b) tx))
                    (y1 (+ (* x c) (* y d) ty)))
                (setf x x1 y y1)
                (plot x y color))))))
      (ctx translate (/ width 2) height)
      (iterate))))

(defun ep-51 ()
  "Pseudo Random Number Generators Part I"
  (let ((digits 10)
        (seed 12234)
        (a 1664525)
        (c 1013904223)
        (m (chain *math (pow 2 31)))
        (y 0))
    (labels ((middle-square-method ()
               (let* ((n (*string (* seed seed)))
                      (start (floor (/ digits 2)))
                      (end (+ start digits)))
                 (while (< (@ n length) (* digits 2))
                   (setf n (+ "0" n)))
                 (setf seed (parse-int (chain n (substring start end))))
                 (/ seed 999999999)))
             (linear-congruential-method ()
               (setf seed (mod (+ (* a seed) c) m))
               ( / seed m))
             (draw ()
               (dotimes (x 550)
                 (when (< (linear-congruential-method) 0.5)
                   (ctx fill-rect x y 1 1)))
               (incf y)
               (when (< y 600)
                 (request-animation-frame draw)))))
    (draw)))

(defun ep-52 ()
  "Pseudo Random Number Generators Part II"
  (let ((seed 1)
        (a 1664525)
        (c 1013904223)
        (m (chain *math (pow 2 31))))
    (labels ((next-random ()
               (setf seed (mod (+ (* a seed) c) m))
               ( / seed m))))
    (setf (ctx-get fill-style) "#ff0000")
    (dotimes (_ 50)
      (let ((x (* (next-random) 600))
            (y (* (next-random) 600))
            (r (+ 20 (* (next-random) 50))))
        (ctx begin-path)
        (ctx arc x y r 0 (* pi 2))
        (ctx fill)))
    (setf seed 1
          (ctx-get fill-style) "#ffff00")
    (dotimes (_ 50)
      (let ((x (* (next-random) 600))
            (y (* (next-random) 600))
            (r (+ 10 (* (next-random) 50))))
        (ctx begin-path)
        (ctx arc x y r 0 (* pi 2))
        (ctx fill)))))

(defun ep-53 ()
  "Random Circle Packing"
  (let ((circles (array))
        (min 5)
        (max 100))
    (labels ((create-circle ()
               (create x (* (random) 600) y (* (random) 600) r min))
             (draw-circle (c)
               (when (> (@ c r) (* max 0.5))
                 (return))
               (ctx begin-path)
               (ctx arc (@ c x) (@ c y) (@ c r) 0 (* pi 2))
               (ctx fill))
             (circle-valid-p (c)
               (when (> (@ c r) max)
                 (return false))
               (dolist (c2 circles)
                 (when (< (distance c c2) (+ (@ c r) (@ c2 r)))
                   (return-from circle-valid-p false)))
               t))
      (def-animation-loop draw
        (let ((counter 0)
              (c (create-circle)))
          (while (not (circle-valid-p c))
            (setf (@ c x) (* (random) 600)
                  (@ c y) (* (random) 600))
            (incf counter)
            (when (> counter 100000)
              (return)))
          (while (circle-valid-p c)
            (incf (@ c r)))
          (decf (@ c r) 2)
          (chain circles (push c))
          (draw-circle c)))
      (setf (ctx-get shadow-color) "rgba(0,0,0,0.5)"
            (ctx-get shadow-offset-x) 5
            (ctx-get shadow-offset-y) 5
            (ctx-get shadow-blur) 10)
      (draw))))

(defun ep-54 ()
  "Dot Product"
  (let ((p0 (create x 200 y 400))
        (p1 (create x 250 y 200))
        (p2 (create x 350 y 150))
        (drag-point))
    (labels ((vec (p0 p1)
               (create x (- (@ p1 x) (@ p0 x)) y (- (@ p1 y) (@ p0 y))))
             (dot-product (v0 v1)
               (+ (* (@ v0 x) (@ v1 x)) (* (@ v0 y) (@ v1 y))))
             (mag (v)
               (with-slots (x y) v
                 (sqrt (+ (* x x) (* y y)))))
             (angle-between (v0 v1)
               (acos (/ (dot-product v0 v1) (* (mag v0) (mag v1)))))
             (draw-point (p)
               (ctx begin-path)
               (ctx arc (@ p x) (@ p y) 10 0 (* pi 2))
               (ctx stroke))
             (draw-lines ()
               (ctx begin-path)
               (ctx move-to (@ p1 x) (@ p1 y))
               (ctx line-to (@ p0 x) (@ p0 y))
               (ctx line-to (@ p2 x) (@ p2 y))
               (ctx stroke))
             (draw ()
               (clear)
               (draw-point p0)
               (draw-point p1)
               (draw-point p2)
               (draw-lines)
               (let* ((v0 (vec p1 p0))
                      (v1 (vec p2 p0))
                      (angle (angle-between v0 v1)))
                 (setf (ctx-get font) "30px Arial")
                 (ctx fill-text (round (rad->degree angle)) 30 30)))
             (hit-test (p x y)
               (< (distance-xy (@ p x) (@ p y) x y) 10))
             (find-drag-point (x y)
               (cond ((hit-test p0 x y) p0)
                     ((hit-test p1 x y) p1)
                     ((hit-test p2 x y) p2)
                     (t null)))
             (on-mouse-down (evt)
               (with-slots (client-x client-y) evt
                 (setf drag-point (find-drag-point client-x client-y))
                 (when drag-point
                   (setf (@ drag-point x) client-x
                         (@ drag-point y) client-y)
                   (draw)
                   (chain document (add-event-listener "mousemove" #'on-mouse-move))
                   (chain document (add-event-listener "mouseup" #'on-mouse-up)))))
             (on-mouse-up ()
               (chain document (remove-event-listener "mousemove" #'on-mouse-move))
               (chain document (remove-event-listener "mouseup" #'on-mouse-up)))
             (on-mouse-move (evt)
               (setf (@ drag-point x) (@ evt client-x)
                     (@ drag-point y) (@ evt client-y))
               (draw)))
      (chain document (add-event-listener "mousedown" #'on-mouse-down))
      (draw))))

(setf (@ window onload) ep-54)
