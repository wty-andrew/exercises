(defvar *canvas* (chain document (get-element-by-id "canvas")))
(defvar *ctx* (chain *canvas* (get-context "2d")))
(defvar *width* (@ window inner-width))
(defvar *height* (@ window inner-height))
(setf (@ *canvas* width) *width*
      (@ *canvas* height) *height*)
(var width *width*)
(var height *height*)

(defun remove-dead-particles (particles)
  (do ((i (1- (@ particles length)) (1- i)))
      ((< i 0))
    (let ((p (aref particles i)))
      (with-slots (x y radius) p
        (when (or (> (- x radius) width)
                  (< (+ x radius) 0)
                  (> (- y radius) height)
                  (< (+ y radius) 0))
          (chain particles (splice i 1)))))))

(defun wrap (p)
  (with-slots (x y radius) p
    (when (> (- x radius) width)
      (setf x (- radius)))
    (when (< (+ x radius) 0)
      (setf x (+ width radius)))
    (when (> (- y radius) height)
      (setf y (- radius)))
    (when (< (+ y radius) 0)
      (setf y (+ height radius)))))

(defun bounce (p)
  (with-slots (x y vx vy radius bounce) p
    (when (> (+ x radius) width)
      (setf x (- width radius)
            vx (* vx bounce)))
    (when (< (- x radius) 0)
      (setf x radius
            vx (* vx bounce)))
    (when (> (+ y radius) height)
      (setf y (- height radius)
            vy (* vy bounce)))
    (when (< (- y radius) 0)
      (setf y radius
            vy (* vy bounce)))))

(defun draw-particle (p)
  (ctx begin-path)
  (ctx arc (particle-x p) (particle-y p) (particle-radius p) 0 (* pi 2) false)
  (ctx fill))

(defun ep-1 ()
  "Introduction"
  (dotimes (_ 100)
    (ctx begin-path)
    (ctx move-to (random-range 0 width) (random-range 0 height))
    (ctx line-to (random-range 0 width) (random-range 0 height))
    (ctx stroke)))

(defun ep-2 ()
  "Intro to Trigonometry"
  (ctx translate 0 (/ height 2))
  (ctx scale 1 -1)
  (do ((angle 0 (+ angle 0.01)))
      ((>= angle (* pi 2)))
    (ctx fill-rect (* angle (/ width (* 2 pi))) (* (sin angle) (/ width (* 2 pi))) 5 5)))

(defun ep-3 ()
  "More Trigonometry"
  (let ((center-y (* height 0.5))
        (center-x (* width 0.5))
        (base-radius 50)
        (base-alpha 0.5)
        (offset-height (* height 0.4))
        (offset-radius 30)
        (offset-alpha 0.5)
        (speed 0.1)
        (angle 0))
    (def-animation-loop render
      (clear)
      (setf y (+ center-y (* (sin angle) offset-height))
            radius (+ base-radius (* (sin (/ angle 2)) offset-radius))
            alpha (+ base-alpha (* (sin (/ angle 2)) offset-alpha))
            (ctx-get fill-style) (concatenate 'string "rgba(0, 0, 0, " alpha ")"))
      (clear)
      (ctx begin-path)
      (ctx arc center-x y radius 0 (* pi 2) false)
      (ctx fill)
      (incf angle speed))
    (render)))

(defun ep-4 ()
  "Circles, Ellipses and Lissajous Curves"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (x-radius (/ width 6))
        (y-radius (/ height 3))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.1)
        (y-speed 0.131)
        x y)
    (def-animation-loop render
      (clear)
      (setf x (+ center-x (* (cos x-angle) x-radius))
            y (+ center-y (* (sin y-angle) y-radius)))
      (ctx begin-path)
      (ctx arc x y 10 0 (* pi 2) false)
      (ctx fill)
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (render)))


(defun ep-5 ()
  "Arctangent"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (arrow-x (/ width 2))
        (arrow-y (/ height 2))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.01)
        (y-speed 0.02)
        dx
        dy
        (angle 0))
    (def-animation-loop render
      (clear)
      (setf arrow-x (+ center-x (* (cos x-angle) (/ width 6)))
            arrow-y (+ center-y (* (sin y-angle) (/ height 3))))
      (with-context ()
        (ctx translate arrow-x arrow-y)
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 20 0)
        (ctx line-to -20 0)
        (ctx move-to 20 0)
        (ctx line-to 10 -10)
        (ctx move-to 20 0)
        (ctx line-to 10 10)
        (ctx stroke))
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf dx (- (@ evt client-x) arrow-x)
                                    dy (- (@ evt client-y) arrow-y)
                                    angle (chain *math (atan2 dy dx))))))
    (render)))

(defun ep-6 ()
  "Vectors, Part I")

(defun ep-7 ()
  "Vectors, Part II"
  (setf v (make-vector 10 5))
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))
  (chain console (log (vec-angle v)))
  (chain console (log (vec-length v)))
  (setf (vec-angle v) (/ pi 6))
  (setf (vec-length v) 100)
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4)
        v3 (v+ v1 v2))
  (chain console (log (vec-x v3)))
  (chain console (log (vec-y v3)))

  (setf v1 (make-vector 10 5)
        v2 (v* v1 2))
  (chain console (log (vec-length v1)))
  (chain console (log (vec-length v2)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4))
  (v+! v1 v2)
  (chain console (log (vec-x v1) (vec-y v1))))

(defun ep-8 ()
  "Velocity"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 2)
                                   (random-range 1 5)
                                   (random-range 0 (* pi 2))))))
    (def-animation-loop update
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 10 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-9 ()
  "Acceleration"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 3)
                                   (random-range 2 7)
                                   (random-range 0 (* pi 2))
                                   0.1))))
    (def-animation-loop update
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 4 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-10 ()
  "Advanced Acceleration"
  (let ((ship (make-particle (/ width 2) (/ height 2) 0 0))
        (thrust (make-vector 0 0))
        (angle 0)
        (turing-left nil)
        (turing-right nil)
        (thrusting nil))
    ;; (setf (particle-friction ship) 0.99) ; from ep-13
    (chain document body (add-event-listener
                          "keydown"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting t)) ; up
                                (37 (setf turing-left t)) ; left
                                (39 (setf turing-right t)))))) ; right
    (chain document body (add-event-listener
                          "keyup"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting nil))
                                (37 (setf turing-left nil))
                                (39 (setf turing-right nil))))))
    (def-animation-loop update
      (clear)
      (when turing-left
        (decf angle 0.05))
      (when turing-right
        (incf angle 0.05))
      (setf (vec-angle thrust) angle
            (vec-length thrust) (if thrusting 0.1 0))
      (particle-accelerate! ship thrust)
        (particle-update! ship)
      (with-context
        (ctx translate (particle-x ship) (particle-y ship))
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 10 0)
        (ctx line-to -10 -7)
        (ctx line-to -10 7)
        (ctx line-to 10 0)
        (when thrusting
          (ctx move-to -10 0)
          (ctx line-to -18 0))
        (ctx stroke))
      (when (> (particle-x ship) width)
        (setf (particle-x ship) 0))
      (when (< (particle-x ship) 0)
        (setf (particle-x ship) width))
      (when (> (particle-y ship) height)
        (setf (particle-y ship) 0))
      (when (< (particle-y ship) 0)
        (setf (particle-y ship) height)))
    (update)))

(defun ep-11 ()
  "Gravity"
  (let ((sun (make-particle (/ width 2) (/ height 2) 0 0))
        (planet (make-particle (+ (/ width 2) 200) (/ height 2) 10 (/ pi -2))))
    (setf (particle-mass sun) 20000)
    (particle-gravitation-add! planet sun)
    (def-animation-loop update
      (clear)
      (particle-update! planet)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#ffff00")
      (ctx arc (particle-x sun) (particle-y sun) 20 0 (* pi 2) false)
      (ctx fill)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#0000ff")
      (ctx arc (particle-x planet) (particle-y planet) 5 0 (* pi 2) false)
      (ctx fill))
    (update)))

(defun ep-12 ()
  "Edge Handling"
  (let* ((num-particles 100)
         (particles
           (loop repeat num-particles
                 collect (let ((particle (make-particle
                                          (/ width 2)
                                          height
                                          (random-range 5 13)
                                          (+ (/ pi -2) (random-range -0.1 0.1))
                                          0.1)))
                           (setf (particle-radius particle) (random-range 2 12)
                                 (particle-bounce particle) -0.9)
                           particle))))

    (defun regenerate (p)
      (with-slots (x y vx vy radius velocity) p
        (when (> (- y radius) height)
          (let ((speed (random-range 5 13))
                (direction (+ (/ pi -2) (random-range -0.1 0.1))))
            (setf x (/ width 2)
                  y height
                  vx (* (cos direction) speed)
                  vy (* (sin direction) speed))))))

    (def-animation-loop update ()
      (clear)
      (dolist (p particles)
        (particle-update! p)
        (draw-particle p)
        ;; (wrap p)
        ;; (regenerate p)
        (bounce p)
        )
      ;; (chain (remove-dead-particles particles))
      )
    (update)))

(defun ep-13 ()
  "Friction"
  (let ((p (make-particle
            (/ width 2)
            (/ height 2)
            10
            (random-range 0 (* pi 2))))
        (friction 0.97))
    (setf (particle-radius p) 10)
    (def-animation-loop update
      (clear)
      (with-slots (vx vy) p
        (setf vx (* vx friction)
              vy (* vy friction))
        (particle-update! p)
        (draw-particle p)))
    (update)))

(defun ep-14 ()
  "Collision Detection"
  (let ((circle0 (create x (random-range 0 width)
                         y (random-range 0 height)
                         radius (random-range 50 150)))
        (circle1 (create x (random-range 0 width)
                         y (random-range 0 height)
                         radius (random-range 50 150)))
        (rect0 (create x 200 y 200 width 200 height 100))
        (rect1 (create x 0 y 0 width 100 height 200)))
    (labels ((draw-circle (circle)
               (with-slots (x y radius) circle
                 (ctx begin-path)
                 (ctx arc x y radius 0 (* pi 2) false)
                 (ctx fill)))
             (draw-rect (rect)
               (with-slots (x y width height) rect
                 (ctx fill-rect x y width height)))
             (pick-color (collide)
               (if collide "#f66" "#999"))
             (detect-point-and-circle (evt)
               (setf (ctx-get fill-style)
                     (pick-color (circle-point-collision (@ evt client-x) (@ evt client-y) circle0)))
               (draw-circle circle0))
             (detect-circle-and-circle (evt)
               (clear)
               (setf (@ circle1 x) (@ evt client-x)
                     (@ circle1 y) (@ evt client-y)
                     (ctx-get fill-style) (pick-color (circle-collision circle0 circle1)))
               (draw-circle circle0)
               (draw-circle circle1))
             (detect-point-and-rect (evt)
               (setf (ctx-get fill-style)
                     (pick-color (point-in-rect (@ evt client-x) (@ evt client-y) rect0)))
               (draw-rect rect0))
             (detect-rect-and-rect (evt)
               (clear)
               (setf (@ rect1 x) (- (@ evt client-x) 50)
                     (@ rect1 y) (- (@ evt client-y) 100)
                     (ctx-get fill-style) (pick-color (rect-intersect rect0 rect1)))
               (draw-rect rect0)
               (draw-rect rect1)))
      (chain document body (add-event-listener
                            "mousemove"
                            ;; #'detect-point-and-circle
                            ;; #'detect-circle-and-circle
                            ;; #'detect-point-and-rect
                            #'detect-rect-and-rect
                            )))))

(defun ep-15 ()
  "Springs Part 1"
  (let ((spring-point (make-vector (/ width 2) (/ height 2)))
        (weight (make-particle
                 (random-range 0 width)
                 (random-range 0 height)
                 50
                 (random-range 0 (* pi 2))))
        (k 0.1))
    (setf (particle-radius weight) 20
          (particle-friction weight) 0.9)
    (particle-spring-add! weight spring-point k)
    (def-animation-loop update ()
      (clear)
      (with-slots (x y radius) weight
        (particle-update! weight)
        (ctx begin-path)
        (ctx arc x y radius 0 (* pi 2) false)
        (ctx fill)
        (ctx begin-path)
        (ctx arc (vec-x spring-point) (vec-y spring-point) 4 0 (* pi 2) false)
        (ctx fill)
        (ctx begin-path)
        (ctx move-to x y)
        (ctx line-to (vec-x spring-point) (vec-y spring-point))
        (ctx stroke)))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf (vec-x spring-point) (@ evt client-x)
                                    (vec-y spring-point) (@ evt client-y)))))
    (update)))

(defun ep-16 ()
  "Springs Part 2"
  (let ((spring-point (make-vector (/ width 2) (/ height 2)))
        (particle-a (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (particle-b (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (particle-c (make-particle (random-range 0 width) (random-range 0 height)
                                   (random-range 0 50) (random-range 0 (* pi 2)) 0.2))
        (k 0.01)
        (separation 200))
    (setf (particle-friction particle-a) 0.9
          (particle-radius particle-a) 20
          (particle-friction particle-b) 0.9
          (particle-radius particle-b) 20
          (particle-friction particle-c) 0.9
          (particle-radius particle-c) 20)
    (particle-spring-add! particle-a particle-b k separation)
    (particle-spring-add! particle-a particle-c k separation)
    (particle-spring-add! particle-b particle-a k separation)
    (particle-spring-add! particle-b particle-c k separation)
    (particle-spring-add! particle-c particle-a k separation)
    (particle-spring-add! particle-c particle-b k separation)
    (def-animation-loop update
      (clear)
      (bounce particle-a)
      (bounce particle-b)
      (bounce particle-c)
      (particle-update! particle-a)
      (particle-update! particle-b)
      (particle-update! particle-c)
      (draw-particle particle-a)
      (draw-particle particle-b)
      (draw-particle particle-c)
      (ctx begin-path)
      (ctx move-to (particle-x particle-a) (particle-y particle-a))
      (ctx line-to (particle-x particle-b) (particle-y particle-b))
      (ctx line-to (particle-x particle-c) (particle-y particle-c))
      (ctx line-to (particle-x particle-a) (particle-y particle-a))
      (ctx stroke))
    (update)))

(defun ep-17 ()
  "Particles - Optimization")

(defun ep-18 ()
  "Particles - Enhancements"
  (let* ((sun1 (make-particle 300 200 0 0))
         (sun2 (make-particle 800 600 0 0))
         (emitter (create x 100 y 0))
         (num-particles 100)
         (particles (loop repeat num-particles
                          collect (let ((p (make-particle
                                             (@ emitter x)
                                             (@ emitter y)
                                             (random-range 7 8)
                                             (+ (/ pi 2) (random-range -0.1 0.1)))))
                                     (particle-gravitation-add! p sun1)
                                     (particle-gravitation-add! p sun2)
                                     (setf (particle-radius p) 3)
                                    p))))
    (setf (particle-mass sun1) 10000
          (particle-radius sun1) 10
          (particle-mass sun2) 20000
          (particle-radius sun2) 20)
    (labels ((draw (p color)
               (setf (ctx-get fill-style) color)
               (draw-particle p)))
      (def-animation-loop update
        (clear)
        (draw sun1 "yellow")
        (draw sun2 "yellow")
        (dolist (p particles)
          (particle-update! p)
          (draw p "black")
          (with-slots (x y) p
            (when (or (> x width)
                      (< x 0)
                      (> y height)
                      (< y 0))
              (setf x (@ emitter x)
                    y (@ emitter y)
                    (particle-speed p) (random-range 7 8)
                    (particle-heading p) (+ (/ pi 2) (random-range -0.1 0.1)))))))
      (update))))

(defun ep-19 ()
  "Bezier Curves"
  (let ((p0 (make-vector (random-range 0 width) (random-range 0 height)))
        (p1 (make-vector (random-range 0 width) (random-range 0 height)))
        (p2 (make-vector (random-range 0 width) (random-range 0 height)))
        (p3 (make-vector (random-range 0 width) (random-range 0 height)))
        (k 0)
        (direction 0.01)
        (p-final (create)))
    (def-animation-loop draw
      (clear)
      (ctx begin-path)
      (ctx move-to (@ p0 x) (@ p0 y))
      (ctx bezier-curve-to (@ p1 x) (@ p1 y) (@ p2 x) (@ p2 y) (@ p3 x) (@ p3 y))
      (ctx stroke)
      (cubic-bezier p0 p1 p2 p3 k p-final)
      (ctx begin-path)
      (ctx arc (@ p-final x) (@ p-final y) 10 0 (* pi 2) false)
      (ctx fill)
      (incf k direction)
      (when (or (> k 1) (< k 0))
        (setf direction (- direction))))
    (draw)))

(defun ep-20 ()
  "More on Bezier Curves"
  (let* ((p0 (make-vector (random-range 0 width) (random-range 0 height)))
         (p1 (make-vector (random-range 0 width) (random-range 0 height)))
         (p2 (make-vector (random-range 0 width) (random-range 0 height)))
         (cp (make-vector (- (* (@ p1 x) 2) (/ (+ (@ p0 x) (@ p2 x)) 2))
                          (- (* (@ p1 y) 2) (/ (+ (@ p0 y) (@ p2 y)) 2))))
         (num-points 10)
         (points (loop repeat num-points
                       collect (make-vector (random-range 0 width) (random-range 0 height)))))
    (labels ((draw-point (p)
               (ctx begin-path)
               (ctx arc (@ p x) (@ p y) 3 0 (* pi 2) false)
               (ctx fill)))
      (dolist (p points)
        (draw-point p))

      (setf (ctx-get stroke-style) "lightgray")
      (ctx begin-path)
      (ctx move-to (@ (aref points 0) x) (@ (aref points 0) y))
      (do* ((i 1 (1+ i))
            (p (aref points i) (aref points i)))
           ((>= i num-points))
        (ctx line-to (@ p x) (@ p y))
        (ctx stroke))

      (setf (ctx-get stroke-style) "black")
      (ctx begin-path)
      (multicurve points *ctx*)
      (ctx stroke))))

(defun ep-21 ()
  "Bitmap Collision Detection"
  (let ((element (chain document (create-element "canvas"))))
    (setf (@ element id) "target")
    (chain document body (append-child element))
    (dolist (el (chain document (query-selector-all "canvas")))
      (with-slots (display position top left) (@ el style)
        (setf display "block"
              position "absolute"
              top "0px"
              left "0px"))))
  (let* ((target-canvas (chain document (get-element-by-id "target")))
         (target-ctx (chain target-canvas (get-context "2d")))
         (p (make-particle 0 (/ height 2) 10 0)))
    (setf (@ target-canvas width) *width*
          (@ target-canvas height) *height*)
    (chain target-ctx (begin-path))
    (chain target-ctx (arc (/ width 2) (/ height 2) 200 0 (* pi 2) false))
    (chain target-ctx (fill))
    (labels ((reset-particle (p)
               (setf (particle-x p) 0
                     (particle-y p) (/ height 2)
                     (particle-heading p) (random-range -0.1 0.1))))
      (def-animation-loop update
        (clear)
        (with-slots (x y) p
          (particle-update! p)
          (ctx begin-path)
          (ctx arc x y 4 0 (* pi 2) false)
          (ctx fill)
          (let ((image-data (chain target-ctx (get-image-data x y 1 1))))
            (cond ((> (aref (@ image-data data) 3) 0)
                   (progn
                     (setf (@ target-ctx global-composite-operation) "destination-out")
                     (chain target-ctx (begin-path))
                     (chain target-ctx (arc x y 20 0 (* pi 2) false))
                     (chain target-ctx (fill))
                     (reset-particle p)))
                  ((> x width) (reset-particle p)))))))
    (update)))

(defun ep-22 ()
  "3D - Postcards in Space"
  (let* ((fl 300)
         (num-shapes 100)
         (shapes (loop repeat num-shapes
                       collect (create x (random-range -1000 1000)
                                       y (random-range -1000 1000)
                                       z (random-range 0 10000)))))
    (ctx translate (/ width 2) (/ height 2))
    (def-animation-loop update
      (ctx clear-rect (/ width -2) (/ height -2) width height)
      (dolist (shape shapes)
        (with-slots (x y z) shape
          (let ((perspective (/ fl (+ fl z))))
            (with-context
              (ctx translate (* x perspective) (* y perspective))
              (ctx scale perspective perspective)
              (ctx fill-rect -100 -100 200 200))
            (incf z 5)
            (when (> z 10000)
              (setf z 0))))))
    (update)))

(defun ep-23 ()
  "3D Carousel"
  (let* ((fl 300)
         (num-cards 7)
         (center-z 1000)
         (radius 1000)
         (base-angle 0)
         (rotation-speed 0.01)
         (cards []))
    (loop for i from 0 to (1- num-cards)
          do (let* ((y 0)
                    (angle (/ (* pi 2 i) num-cards))
                    (img (chain document (create-element "img")))
                    (x (* (cos (+ angle base-angle)) radius))
                    (z (+ center-z (* (sin (+ angle base-angle)) radius))))
               (setf (@ img src) (+ "http://picsum.photos/id/" i "/300/200"))
               (chain cards (push (create x x y y z z angle angle img img)))))
    (ctx translate (/ width 2) (/ height 2))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf rotation-speed (* (- (@ evt client-x) (/ width 2)) 0.00005)))))
    (labels ((zsort (card-a card-b)
               (- (@ card-b z) (@ card-a z))))
      (def-animation-loop update
        (incf base-angle rotation-speed)
        (chain cards (sort zsort))
        (ctx clear-rect (/ width -2) (/ height -2) width height)
        (dolist (card cards)
          (with-slots (x y z angle img) card
            (let ((perspective (/ fl (+ fl z))))
              (with-context
                (ctx scale perspective perspective)
                (ctx translate x y)
                (ctx translate (/ (@ img width) -2) (/ (@ img height) -2))
                (ctx draw-image img 0 0)))
            (setf x (* (cos (+ angle base-angle)) radius)
                  z (+ center-z (* (sin (+ angle base-angle)) radius)))))))
    (update)))

(defun ep-24 ()
  "3D Points and Lines"
  (let* ((fl 300)
         (num-points 200)
         (center-z 2000)
         (radius 1000)
         (base-angle 0)
         (rotation-speed 0.01)
         (points (loop for i from 0 to (1- num-points)
                       collect (let* ((angle (* 0.2 i))
                                      (y (+ (- 2000 (/ (* 4000 i) num-points))
                                            (* (random) 500)))
                                      (x (* (cos (+ angle base-angle)) radius))
                                      (z (+ center-z (* (sin (+ angle base-angle)) radius))))
                                 (create x x y y z z angle angle)))))
    (ctx translate (/ width 2) (/ height 2))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf rotation-speed (* (- (@ evt client-x) (/ width 2)) 0.00005)
                                    ypos (* (- (@ evt client-y) (/ height 2)) 2)))))
  (def-animation-loop update
    (incf base-angle rotation-speed)
    (ctx clear-rect (/ width -2) (/ height -2) width height)
    (ctx begin-path)
    (dotimes (i (@ points length))
      (with-slots (x y z angle) (aref points i)
        (let ((perspective (/ fl (+ fl z))))
          (with-context
            (ctx scale perspective perspective)
            (ctx translate x y)
            (if (= 0 i)
                (ctx move-to 0 0)
                (ctx line-to 0 0))))
        (setf x (* (cos (+ angle base-angle)) radius)
              z (+ center-z (* (sin (+ angle base-angle)) radius)))))
    (ctx stroke))
    (update)))

(defun ep-25 ()
  "3D Modeling, Points and Lines Part 2"
  (let ((fl 300)
        (points (array (create x -500 y -500 z 1000)
                       (create x 500 y -500 z 1000)
                       (create x 500 y -500 z 500)
                       (create x -500 y -500 z 500)
                       (create x -500 y 500 z 1000)
                       (create x 500 y 500 z 1000)
                       (create x 500 y 500 z 500)
                       (create x -500 y 500 z 500)))
        (needs-update t))
    (ctx translate (/ width 2) (/ height 2))
    (labels ((project ()
               (dolist (p points)
                 (with-slots (x y z) p
                   (let ((scale (/ fl (+ fl z))))
                     (setf (@ p sx) (* x scale)
                           (@ p sy) (* y scale))))))
             (draw-line ()
               (let ((p (aref points (aref arguments 0))))
                 (ctx move-to (@ p sx) (@ p sy))
                 (loop for i from 1 to (1- (@ arguments length))
                       do (let ((p (aref points (aref arguments i))))
                            (ctx line-to (@ p sx) (@ p sy))))))
             (translate-model (x y z)
               (dolist (p points)
                 (incf (@ p x) x)
                 (incf (@ p y) y)
                 (incf (@ p z) z))
               (setf needs-update t)))
      (chain document body (add-event-listener
                            "keydown"
                            #'(lambda (evt)
                                (case (@ evt key-code)
                                  (37 (translate-model -20 0 0))
                                  (39 (translate-model 20 0 0))
                                  (38 (if (@ evt shift-key)
                                          (translate-model 0 0 20)
                                          (translate-model 0 -20 0)))
                                  (40 (if (@ evt shift-key)
                                          (translate-model 0 0 -20)
                                          (translate-model 0 20 0)))))))
      (def-animation-loop update
        (when needs-update
          (ctx clear-rect (/ width -2) (/ height -2) width height)
          (project)
          (ctx begin-path)
          (draw-line 0 1 2 3 0)
          (draw-line 4 5 6 7 4)
          (draw-line 0 4)
          (draw-line 1 5)
          (draw-line 2 6)
          (draw-line 3 7)
          (ctx stroke)
          (setf needs-update nil))))
    (update)))

(defun ep-26 ()
  "2D and 3D Coordinate Rotation"
  (let ((fl 300)
        (center-z 1500)
        (points (array (create x -500 y -500 z 500)
                       (create x 500 y -500 z 500)
                       (create x 500 y -500 z -500)
                       (create x -500 y -500 z -500)
                       (create x -500 y 500 z 500)
                       (create x 500 y 500 z 500)
                       (create x 500 y 500 z -500)
                       (create x -500 y 500 z -500)))
        (needs-update t))
    (ctx translate (/ width 2) (/ height 2))
    (labels ((project ()
               (dolist (p points)
                 (with-slots (x y z) p
                   (let ((scale (/ fl (+ fl z center-z))))
                     (setf (@ p sx) (* x scale)
                           (@ p sy) (* y scale))))))
             (draw-line ()
               (let ((p (aref points (aref arguments 0))))
                 (ctx move-to (@ p sx) (@ p sy))
                 (loop for i from 1 to (1- (@ arguments length))
                       do (let ((p (aref points (aref arguments i))))
                            (ctx line-to (@ p sx) (@ p sy))))))
             (translate-model (x y z)
               (dolist (p points)
                 (incf (@ p x) x)
                 (incf (@ p y) y)
                 (incf (@ p z) z))
               (setf needs-update t))
             (rotate-x (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (y z) p
                     (setf y (- (* y cos) (* z sin))
                           z (+ (* z cos) (* y sin))))))
               (setf needs-update t))
             (rotate-y (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (x z) p
                     (setf x (- (* x cos) (* z sin))
                           z (+ (* z cos) (* x sin))))))
               (setf needs-update t))
             (rotate-z (angle)
               (let ((cos (cos angle))
                     (sin (sin angle)))
                 (dolist (p points)
                   (with-slots (x y) p
                     (setf x (- (* x cos) (* y sin))
                           y (+ (* y cos) (* x sin))))))
               (setf needs-update t)))
      (chain document body (add-event-listener
                            "keydown"
                            #'(lambda (evt)
                                (case (@ evt key-code)
                                  (37 (if (@ evt ctrl-key)
                                          (rotate-y 0.05)
                                          (translate-model -20 0 0)))
                                  (39 (if (@ evt ctrl-key)
                                          (rotate-y -0.05)
                                          (translate-model 20 0 0)))
                                  (38 (cond ((@ evt shift-key) (translate-model 0 0 20))
                                            ((@ evt ctrl-key) (rotate-x 0.05))
                                            (t (translate-model 0 -20 0))))
                                  (40 (cond ((@ evt shift-key) (translate-model 0 0 -20))
                                            ((@ evt ctrl-key) (rotate-x -0.05))
                                            (t (translate-model 0 20 0))))))))
      (def-animation-loop update
        (when needs-update
          (ctx clear-rect (/ width -2) (/ height -2) width height)
          (project)
          (ctx begin-path)
          (draw-line 0 1 2 3 0)
          (draw-line 4 5 6 7 4)
          (draw-line 0 4)
          (draw-line 1 5)
          (draw-line 2 6)
          (draw-line 3 7)
          (ctx stroke)
          (setf needs-update nil))))
    (update)))

(defun ep-27 ()
  "Easing and Tweening"
  (let ((target (make-vector width (* (random) height)))
        (position (make-vector 0 (* (random) height)))
        (ease 0.1))
    (chain document body (add-event-listener
                            "mousemove"
                            #'(lambda (evt)
                                (setf (@ target x) (@ evt client-x)
                                      (@ target y) (@ evt client-y)))))
    (def-animation-loop update ()
      (with-slots (x y) position
        (clear)
        (ctx begin-path)
        (ctx arc x y 10 0 (* pi 2) false)
        (ctx fill)
        (incf x (* (- (@ target x) x) ease))
        (incf y (* (- (@ target y) y) ease))))
    (update)))

(defun ep-28 ()
  "More on Easing"
  (let* ((target (make-vector width (* (random) height)))
         (num-points 100)
         (points (loop repeat num-points
                       collect (make-vector 0 0)))
        (ease 0.5))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf (@ target x) (@ evt client-x)
                                    (@ target y) (@ evt client-y)))))
    (labels ((ease-to (position target ease)
               (with-slots (x y) position
                 (incf x (* (- (@ target x) x) ease))
                 (incf y (* (- (@ target y) y) ease)))))
      (def-animation-loop update ()
        (clear)
        (let ((leader (make-vector (@ target x) (@ target y))))
          (loop for i from 1 to (1- num-points)
                do (let ((point (aref points i)))
                     (with-slots (x y) point
                       (ease-to point leader ease)
                       (ctx begin-path)
                       (ctx arc x y 10 0 (* pi 2) false)
                       (ctx fill)
                       (setf (@ leader x) x
                             (@ leader y) y)))))))
    (update)))

(defun ep-29 ()
  "Tweening Part I"
  (let ((start (create x 100 y 100))
        (target (create))
        (change (create))
        start-time
        (duration 1000))
    (labels ((draw-circle (x y)
               (ctx begin-path)
               (ctx arc x y 20 0 (* pi 2) false)
               (ctx fill))
             (linear-tween (k b c d)
               (+ (/ (* c k) d) b))
             (ease-in-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* c k k) b)))
             (ease-out-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* (- c) k (- k 2)) b)))
             (ease-in-out-quad (k b c d)
               (let ((k (/ k (/ d 2))))
                 (if (< k 1)
                     (+ (/ (* c k k) 2) b)
                     (+ (* (/ c -2) (1- (* (1- k) (- k 3)))) b)))))
      (with-slots ((start-x x) (start-y y)) start
        (draw-circle start-x start-y)
        (chain document body (add-event-listener
                              "click"
                              #'(lambda (evt)
                                  (setf (@ target x) (@ evt client-x)
                                        (@ target y) (@ evt client-y)
                                        (@ change x) (- (@ target x) start-x)
                                        (@ change y) (- (@ target y) start-y)
                                        start-time (new (*date)))
                                  (update))))
        (def-animation-loop update
          (clear)
          (let ((time (- (new (*date)) start-time)))
            (if (< time duration)
                (let ((x (ease-in-out-quad time start-x (@ change x) duration))
                      (y (ease-in-out-quad time start-y (@ change y) duration)))
                  (draw-circle x y))
                (progn
                  (draw-circle (@ target x) (@ target y))
                  (setf (@ start x) (@ target x)
                        (@ start y) (@ target y))))))))))

(defun ep-30 ()
  "Tweening Part II"
  (let ((ball (create x 100 y 100 alpha 1))
        (duration 1000))
    (labels ((draw-circle (x y)
               (ctx begin-path)
               (ctx arc x y 20 0 (* pi 2) false)
               (ctx fill))
             (linear-tween (k b c d)
               (+ (/ (* c k) d) b))
             (ease-in-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* c k k) b)))
             (ease-out-quad (k b c d)
               (let ((k (/ k d)))
                 (+ (* (- c) k (- k 2)) b)))
             (ease-in-out-quad (k b c d)
               (let ((k (/ k (/ d 2))))
                 (if (< k 1)
                     (+ (/ (* c k k) 2) b)
                     (+ (* (/ c -2) (1- (* (1- k) (- k 3)))) b))))
             (render ()
               (clear)
               (ctx begin-path)
               (setf (ctx-get global-alpha) (@ ball alpha))
               (ctx arc (@ ball x) (@ ball y) 20 0 (* pi 2) false)
               (ctx fill))
             (tween (obj props duration easing-func on-progress on-complete)
               (let* ((starts (create))
                      (changes (create))
                      (start-time (new (*date))))
                 (for-in (prop props)
                         (setf (getprop starts prop) (getprop obj prop)
                               (getprop changes prop) (- (getprop props prop)
                                                         (getprop starts prop))))
                 (labels ((update ()
                            (let ((time (- (new (*date)) start-time)))
                              (if (< time duration)
                                  (progn
                                    (for-in (prop props)
                                            (setf (getprop obj prop)
                                                  (easing-func time
                                                               (getprop starts prop)
                                                               (getprop changes prop)
                                                               duration)))
                                    (on-progress)
                                    (request-animation-frame update))
                                  (progn
                                    (setf time duration)
                                    (for-in (prop props)
                                            (setf (getprop obj prop)
                                                  (easing-func time
                                                               (getprop starts prop)
                                                               (getprop changes prop)
                                                               duration)))
                                    (on-complete))))))
                   (update))))
             (tween-back ()
               (tween ball (create x 100 y 100 alpha 1) 1000 ease-in-out-quad render render)))
      (tween ball (create x 900 y 700 alpha 0) 1000 ease-in-out-quad render tween-back))))

(defun ep-31 ()
  "Tweening Part III")

(defun ep-32 ()
  "Line Intersections Part I"
  (labels ((line-intersect (p0 p1 p2 p3)
             (let* ((a1 (- (@ p1 y) (@ p0 y)))
                    (b1 (- (@ p0 x) (@ p1 x)))
                    (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                    (a2 (- (@ p3 y) (@ p2 y)))
                    (b2 (- (@ p2 x) (@ p3 x)))
                    (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                    (denominator (- (* a1 b2) (* a2 b1))))
               (create x (/ (- (* b2 c1) (* b1 c2)) denominator)
                       y (/ (- (* a1 c2) (* a2 c1)) denominator)))))
    (let* ((p0 (create x 100 y 100))
           (p1 (create x 500 y 500))
           (p2 (create x 600 y 50))
           (p3 (create x 80 y 600))
           (intersect (line-intersect p0 p1 p2 p3)))
      (ctx begin-path)
      (ctx move-to (@ p0 x) (@ p0 y))
      (ctx line-to (@ p1 x) (@ p1 y))
      (ctx move-to (@ p2 x) (@ p2 y))
      (ctx line-to (@ p3 x) (@ p3 y))
      (ctx stroke)
      (ctx begin-path)
      (ctx arc (@ intersect x) (@ intersect y) 20 0 (* pi 2) false)
      (ctx stroke))))

(defun ep-33 ()
  "Line Intersections Part II"
  (let* ((p0 (create x 100 y 100))
         (p1 (create x 500 y 500))
         (p2 (create x 600 y 50))
         (p3 (create x 80 y 600))
         click-point)
    (labels ((line-intersect (p0 p1 p2 p3)
             (let* ((a1 (- (@ p1 y) (@ p0 y)))
                    (b1 (- (@ p0 x) (@ p1 x)))
                    (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                    (a2 (- (@ p3 y) (@ p2 y)))
                    (b2 (- (@ p2 x) (@ p3 x)))
                    (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                    (denominator (- (* a1 b2) (* a2 b1))))
               (if (= denominator 0)
                   nil
                   (create x (/ (- (* b2 c1) (* b1 c2)) denominator)
                           y (/ (- (* a1 c2) (* a2 c1)) denominator)))))
             (segment-intersect (p0 p1 p2 p3)
               (let* ((a1 (- (@ p1 y) (@ p0 y)))
                      (b1 (- (@ p0 x) (@ p1 x)))
                      (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                      (a2 (- (@ p3 y) (@ p2 y)))
                      (b2 (- (@ p2 x) (@ p3 x)))
                      (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                      (denominator (- (* a1 b2) (* a2 b1))))
                 (if (= denominator 0)
                     nil
                     (let* ((intersect-x (/ (- (* b2 c1) (* b1 c2)) denominator))
                            (intersect-y (/ (- (* a1 c2) (* a2 c1)) denominator))
                            (rx0 (/ (- intersect-x (@ p0 x)) (- (@ p1 x) (@ p0 x))))
                            (ry0 (/ (- intersect-y (@ p0 y)) (- (@ p1 y) (@ p0 y))))
                            (rx1 (/ (- intersect-x (@ p2 x)) (- (@ p3 x) (@ p2 x))))
                            (ry1 (/ (- intersect-y (@ p2 y)) (- (@ p3 y) (@ p2 y)))))
                       (if (and (or (and (>= rx0 0) (<= rx0 1))
                                    (and (>= ry0 0) (<= ry0 1)))
                                (or (and (>= rx1 0) (<= rx1 1))
                                    (and (>= ry1 0) (<= ry1 1))))
                           (create x intersect-x y intersect-y)
                           nil)))))
             (get-click-point (x y)
               (let ((points (array p0 p1 p2 p3)))
                 (dolist (p points)
                   (let* ((dx (- (@ p x) x))
                          (dy (- (@ p y) y))
                          (dist (sqrt (+ (* dx dx) (* dy dy)))))
                     (when (< dist 10)
                       (return p))))))
             (on-mouse-down (evt)
               (setf click-point (get-click-point (@ evt client-x) (@ evt client-y)))
               (when click-point
                 (chain document body (add-event-listener "mousemove" on-mouse-move))
                 (chain document body (add-event-listener "mouseup" on-mouse-up))))
             (on-mouse-move (evt)
               (setf (@ click-point x) (@ evt client-x)
                     (@ click-point y) (@ evt client-y))
               (render))
             (on-mouse-up(evt)
               (chain document body (remove-event-listener "mousemove" on-mouse-move))
               (chain document body (remove-event-listener "mouseup" on-mouse-up)))
             (draw-point (p)
               (ctx begin-path)
               (ctx arc (@ p x) (@ p y) 10 0 (* pi 2) false)
               (ctx fill))
             (render ()
               (clear)
               (draw-point p0)
               (draw-point p1)
               (draw-point p2)
               (draw-point p3)
               (ctx begin-path)
               (ctx move-to (@ p0 x) (@ p0 y))
               (ctx line-to (@ p1 x) (@ p1 y))
               (ctx move-to (@ p2 x) (@ p2 y))
               (ctx line-to (@ p3 x) (@ p3 y))
               (ctx stroke)
               (let ((intersect (segment-intersect p0 p1 p2 p3)))
                 (when intersect
                   (ctx begin-path)
                   (ctx arc (@ intersect x) (@ intersect y) 20 0 (* pi 2) false)
                   (ctx stroke)))))
      (chain document body (add-event-listener "mousedown" on-mouse-down))
      (render))))

(defun ep-34 ()
  "Line Intersections Part III"
  (let ((star0 (create x 200
                       y 200
                       points (array (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0))
                       offset (array (create x 100 y 0)
                                     (create x 40 y 29)
                                     (create x 31 y 95)
                                     (create x -15 y 48)
                                     (create x -81 y 59)
                                     (create x -50 y 0)
                                     (create x -81 y -59)
                                     (create x -15 y -48)
                                     (create x 31 y -95)
                                     (create x 40 y -29))))
        (star1 (create x 600
                       y 500
                       points (array (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0)
                                     (create x 0 y 0))
                       offset (array (create x 100 y 0)
                                     (create x 40 y 29)
                                     (create x 31 y 95)
                                     (create x -15 y 48)
                                     (create x -81 y 59)
                                     (create x -50 y 0)
                                     (create x -81 y -59)
                                     (create x -15 y -48)
                                     (create x 31 y -95)
                                     (create x 40 y -29)))))
    (labels ((update-star (star)
               (with-slots (x y points offset) star
                 (dotimes (i (@ points length))
                   (setf (@ (aref points i) x) (+ x (@ (aref offset i) x))
                         (@ (aref points i) y) (+ y (@ (aref offset i) y))))))
             (draw-star (star)
               (with-slots (points) star
                 (ctx begin-path)
                 (ctx move-to (@ (aref points 0) x) (@ (aref points 0) y))
                 (dolist (p (chain points (slice 1)))
                   (ctx line-to (@ p x) (@ p y)))
                 (ctx close-path)
                 (ctx fill)))
             (segment-intersect (p0 p1 p2 p3)
               (let* ((a1 (- (@ p1 y) (@ p0 y)))
                      (b1 (- (@ p0 x) (@ p1 x)))
                      (c1 (+ (* a1 (@ p0 x)) (* b1 (@ p0 y))))
                      (a2 (- (@ p3 y) (@ p2 y)))
                      (b2 (- (@ p2 x) (@ p3 x)))
                      (c2 (+ (* a2 (@ p2 x)) (* b2 (@ p2 y))))
                      (denominator (- (* a1 b2) (* a2 b1))))
                 (if (= denominator 0)
                     nil
                     (let* ((intersect-x (/ (- (* b2 c1) (* b1 c2)) denominator))
                            (intersect-y (/ (- (* a1 c2) (* a2 c1)) denominator))
                            (rx0 (/ (- intersect-x (@ p0 x)) (- (@ p1 x) (@ p0 x))))
                            (ry0 (/ (- intersect-y (@ p0 y)) (- (@ p1 y) (@ p0 y))))
                            (rx1 (/ (- intersect-x (@ p2 x)) (- (@ p3 x) (@ p2 x))))
                            (ry1 (/ (- intersect-y (@ p2 y)) (- (@ p3 y) (@ p2 y)))))
                       (if (and (or (and (>= rx0 0) (<= rx0 1))
                                    (and (>= ry0 0) (<= ry0 1)))
                                (or (and (>= rx1 0) (<= rx1 1))
                                    (and (>= ry1 0) (<= ry1 1))))
                           (create x intersect-x y intersect-y)
                           nil)))))
             (check-star-collision (star-a star-b)
               (let ((num-points (@ star-a points length)))
                 (dotimes (i num-points)
                   (let ((p0 (aref (@ star-a points) i))
                         (p1 (aref (@ star-a points) (mod (1+ i) num-points))))
                     (dotimes (j num-points)
                       (let ((p2 (aref (@ star-b points) j))
                             (p3 (aref (@ star-b points) (mod (1+ j) num-points))))
                         (when (segment-intersect p0 p1 p2 p3)
                           (return-from check-star-collision t)))))))
               false))
      (chain document body (add-event-listener
                            "mousemove"
                            #'(lambda (evt)
                                (clear)
                                (setf (@ star0 x) (@ evt client-x)
                                      (@ star0 y) (@ evt client-y))
                                (update-star star0)
                                (update-star star1)
                                (setf (ctx-get fill-style)
                                      (if (check-star-collision star0 star1)
                                          "red"
                                          "black"))
                                (draw-star star0)
                                (draw-star star1)))))))

(defun ep-35 ()
  "Intro to Fractals"
  (labels ((draw-triangle (p0 p1 p2)
             (ctx move-to (@ p0 x) (@ p0 y))
             (ctx line-to (@ p1 x) (@ p1 y))
             (ctx line-to (@ p2 x) (@ p2 y))
             (ctx fill))
           (sierpinski (p0 p1 p2 limit)
             (if (> limit 0)
                 (let ((p-a (create x (/ (+ (@ p0 x) (@ p1 x)) 2)
                                    y (/ (+ (@ p0 y) (@ p1 y)) 2)))
                       (p-b (create x (/ (+ (@ p1 x) (@ p2 x)) 2)
                                    y (/ (+ (@ p1 y) (@ p2 y)) 2)))
                       (p-c (create x (/ (+ (@ p2 x) (@ p0 x)) 2)
                                    y (/ (+ (@ p2 y) (@ p0 y)) 2))))
                   (sierpinski p0 p-a p-c (1- limit))
                   (sierpinski p-a p1 p-b (1- limit))
                   (sierpinski p-c p-b p2 (1- limit)))
                 (draw-triangle p0 p1 p2)))
           (koch (p0 p1 limit)
             (let* ((dx (- (@ p1 x) (@ p0 x)))
                    (dy (- (@ p1 y) (@ p0 y)))
                    (dist (sqrt (+ (* dx dx) (* dy dy))))
                    (unit (/ dist 3))
                    (angle (chain *math (atan2 dy dx)))
                    (p-a (create x (+ (@ p0 x) (/ dx 3))
                                 y (+ (@ p0 y) (/ dy 3))))
                    (p-c (create x (- (@ p1 x) (/ dx 3))
                                 y (- (@ p1 y) (/ dy 3))))
                    (p-b (create x (+ (@ p-a x) (* (cos (- angle (/ pi 3))) unit))
                                 y (+ (@ p-a y) (* (sin (- angle (/ pi 3))) unit)))))
               (if (> limit 0)
                   (progn
                     (koch p0 p-a (1- limit))
                     (koch p-a p-b (1- limit))
                     (koch p-b p-c (1- limit))
                     (koch p-c p-1 (1- limit)))
                   (progn
                     (ctx begin-path)
                     (ctx move-to (@ p0 x) (@ p0 y))
                     (ctx line-to (@ p-a x) (@ p-a y))
                     (ctx line-to (@ p-b x) (@ p-b y))
                     (ctx line-to (@ p-c x) (@ p-c y))
                     (ctx line-to (@ p-1 x) (@ p-1 y))
                     (ctx stroke))))))
    (let ((p0 (create x 0 y -321))
          (p1 (create x 278 y 160))
          (p2 (create x -278 y 160)))
      (ctx translate (/ width 2) (/ height 2))
      ;; (sierpinski p0 p1 p2 3)
      (koch p0 p1 5)
      (koch p1 p2 5)
      (koch p2 p0 5))))

(defun ep-36 ()
  "Verlet Integration Part I"
  (let ((points (array (create x 100 y 100 oldx 95 oldy 95)))
        (bounce 0.9)
        (gravity 0.5)
        (friction 0.999))
    (labels ((update-points ()
               (dolist (p points)
                 (with-slots (x y oldx oldy) p
                   (let ((vx (* (- x oldx) friction))
                         (vy (* (- y oldy) friction)))
                     (setf oldx x
                           oldy y
                           x (+ x vx)
                           y (+ y vy gravity))
                     (when (> x width)
                       (setf x width
                             oldx (+ x (* vx bounce))))
                     (when (< x 0)
                       (setf x 0
                             oldx (+ x (* vx bounce))))
                     (when (> y height)
                       (setf y height
                             oldy (+ y (* vy bounce))))
                     (when (< y 0)
                       (setf y 0
                             oldy (+ y (* vy bounce))))))))
             (render-points ()
               (clear)
               (dolist (p points)
                 (with-slots (x y) p
                   (ctx begin-path)
                   (ctx arc x y 5 0 (* pi 2))
                   (ctx fill)))))
      (def-animation-loop update ()
        (update-points)
        (render-points))
      (update))))

(setf (@ window onload) ep-36)
