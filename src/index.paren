(defvar *canvas* (chain document (get-element-by-id "canvas")))
(defvar *ctx* (chain *canvas* (get-context "2d")))
(defvar *width* (@ window inner-width))
(defvar *height* (@ window inner-height))
(setf (@ *canvas* width) *width*
      (@ *canvas* height) *height*)
(var width *width*)
(var height *height*)

;; utils
(defmacro exports (&rest args)
  "Make args available in global scope."
  `(setf ,@(mapcan #'(lambda (arg)
                       `((chain window ,arg) ,arg))
                   args)))

;; canvas
(defmacro ctx (fn &rest args)
  `(chain *ctx* (,fn ,@args)))

(defmacro ctx-get (attr)
  `(@ *ctx* ,attr))

(defmacro clear ()
  `(ctx clear-rect 0 0 *width* *height*))

(defmacro with-context (&body body)
  `(progn
     (ctx save)
     ,@body
     (ctx restore)))

(defmacro def-animation-loop (name &body body)
  `(defun ,name ()
     (clear)
     ,@body
     (request-animation-frame ,name)))

;; vector
(defun make-vector (&optional (x 0) (y 0))
  (create x x y y))

(defmacro vec-x (vec)
  `(@ ,vec x))

(defsetf vec-x (vec) (value)
  `(setf (@ ,vec x) ,value))

(defmacro vec-y (vec)
  `(@ ,vec y))

(defsetf vec-y (vec) (value)
  `(setf (@ ,vec y) ,value))

(defun vec-angle (vec)
  (chain *math (atan2 (vec-y vec) (vec-x vec))))

(defsetf vec-angle (vec) (angle)
  `(let ((length (vec-length ,vec)))
     (setf (vec-x ,vec) (* (cos ,angle) length)
           (vec-y ,vec) (* (sin ,angle) length))))

(defun vec-length (vec)
  (with-slots (x y) vec
    (sqrt (+ (* x x) (* y y)))))

(defsetf vec-length (vec) (length)
  `(let ((angle (vec-angle ,vec)))
     (setf (vec-x ,vec) (* (cos angle) ,length)
           (vec-y ,vec) (* (sin angle) ,length))))

(defun v+ (v1 v2)
  (make-vector (+ (vec-x v1) (vec-x v2))
               (+ (vec-y v1) (vec-y v2))))

(defun v- (v1 v2)
  (make-vector (- (vec-x v1) (vec-x v2))
               (- (vec-y v1) (vec-y v2))))

(defun v* (v scalar)
  (make-vector (* (vec-x v) scalar)
               (* (vec-y v) scalar)))

(defun v/ (v scalar)
  (v* v (/ 1 scalar)))

(defun v+! (v1 v2)
  (incf (vec-x v1) (vec-x v2))
  (incf (vec-y v1) (vec-y v2)))

(defun v-! (v1 v2)
  (decf (vec-x v1) (vec-x v2))
  (decf (vec-y v1) (vec-y v2)))

(defun v*! (v scalar)
  (setf (vec-x v) (* (vec-x v) scalar)
        (vec-y v) (* (vec-y v) scalar)))

(defun v/! (v scalar)
  (v*! v (/ 1 scalar)))

(defun distance (v1 v2)
  (let ((dx (- (vec-x v2) (vec-x v1)))
        (dy (- (vec-y v2) (vec-y v1))))
    (sqrt (+ (* dx dx) (* dy dy)))))

(defun angle-between (v1 v2)
  (chain *math (atan2 (- (vec-y v2) (vec-y v1))
                      (- (vec-x v2) (vec-x v1)))))

;; particle
(defun make-particle (x y speed direction &optional (gravity 0))
  (let ((position (make-vector x y))
        (velocity (make-vector 0 0)))
    (setf (vec-length velocity) speed
          (vec-angle velocity) direction)
    (create position position
            velocity velocity
            mass 1
            radius 0
            bounce -1
            gravity (make-vector 0 gravity))))

(defmacro particle-pos (p)
  `(@ ,p position))

(defmacro particle-vel (p)
  `(@ ,p velocity))

(defmacro particle-x (p)
  `(vec-x (particle-pos ,p)))

(defsetf particle-x (p) (value)
  `(setf (vec-x (particle-pos ,p)) ,value))

(defmacro particle-y (p)
  `(vec-y (particle-pos ,p)))

(defsetf particle-y (p) (value)
  `(setf (vec-y (particle-pos ,p)) ,value))

(defmacro particle-mass (p)
  `(@ ,p mass))

(defmacro particle-radius (p)
  `(@ ,p radius))

(defmacro particle-bounce (p)
  `(@ ,p bounce))

(defmacro particle-grav (p)
  `(@ ,p gravity))

(defun particle-update! (p)
  (v+! (particle-vel p) (particle-grav p))
  (v+! (particle-pos p) (particle-vel p)))

(defun particle-accelerate! (p accel)
  (v+! (particle-vel p) accel))

(defun particle-gravitate-to! (p1 p2)
  (let ((grav (make-vector 0 0))
        (dist (distance (particle-pos p1) (particle-pos p2))))
    (setf (vec-length grav) (/ (particle-mass p2) (* dist dist))
          (vec-angle grav) (angle-between (particle-pos p1) (particle-pos p2)))
    (v+! (particle-vel p1) grav)))

(defun ep-1 ()
  "Introduction"
  (dotimes (_ 100)
    (ctx begin-path)
    (ctx move-to (* (random) width) (* (random) height))
    (ctx line-to (* (random) width) (* (random) height))
    (ctx stroke)))

(defun ep-2 ()
  "Intro to Trigonometry"
  (ctx translate 0 (/ height 2))
  (ctx scale 1 -1)
  (do ((angle 0 (+ angle 0.01)))
      ((>= angle (* pi 2)))
    (ctx fill-rect (* angle (/ width (* 2 pi))) (* (sin angle) (/ width (* 2 pi))) 5 5)))

(defun ep-3 ()
  "More Trigonometry"
  (let ((center-y (* height 0.5))
        (center-x (* width 0.5))
        (base-radius 50)
        (base-alpha 0.5)
        (offset-height (* height 0.4))
        (offset-radius 30)
        (offset-alpha 0.5)
        (speed 0.1)
        (angle 0))
    (def-animation-loop render
      (setf y (+ center-y (* (sin angle) offset-height))
            radius (+ base-radius (* (sin (/ angle 2)) offset-radius))
            alpha (+ base-alpha (* (sin (/ angle 2)) offset-alpha))
            (ctx-get fill-style) (concatenate 'string "rgba(0, 0, 0, " alpha ")"))
      (clear)
      (ctx begin-path)
      (ctx arc center-x y radius 0 (* pi 2) false)
      (ctx fill)
      (incf angle speed))
    (render)))

(defun ep-4 ()
  "Circles, Ellipses and Lissajous Curves"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (x-radius (/ width 6))
        (y-radius (/ height 3))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.1)
        (y-speed 0.131)
        x y)
    (def-animation-loop render
      (setf x (+ center-x (* (cos x-angle) x-radius))
            y (+ center-y (* (sin y-angle) y-radius)))
      (ctx begin-path)
      (ctx arc x y 10 0 (* pi 2) false)
      (ctx fill)
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (render)))


(defun ep-5 ()
  "Arctangent"
  (let ((center-x (/ width 2))
        (center-y (/ height 2))
        (arrow-x (/ width 2))
        (arrow-y (/ height 2))
        (x-angle 0)
        (y-angle 0)
        (x-speed 0.01)
        (y-speed 0.02)
        dx
        dy
        (angle 0))
    (def-animation-loop render
      (setf arrow-x (+ center-x (* (cos x-angle) (/ width 6)))
            arrow-y (+ center-y (* (sin y-angle) (/ height 3))))
      (with-context ()
        (ctx translate arrow-x arrow-y)
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 20 0)
        (ctx line-to -20 0)
        (ctx move-to 20 0)
        (ctx line-to 10 -10)
        (ctx move-to 20 0)
        (ctx line-to 10 10)
        (ctx stroke))
      (incf x-angle x-speed)
      (incf y-angle y-speed))
    (chain document body (add-event-listener
                          "mousemove"
                          #'(lambda (evt)
                              (setf dx (- (@ evt client-x) arrow-x)
                                    dy (- (@ evt client-y) arrow-y)
                                    angle (chain *math (atan2 dy dx))))))
    (render)))

(defun ep-6 ()
  "Vectors, Part I")

(defun ep-7 ()
  "Vectors, Part II"
  (setf v (make-vector 10 5))
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))
  (chain console (log (vec-angle v)))
  (chain console (log (vec-length v)))
  (setf (vec-angle v) (/ pi 6))
  (setf (vec-length v) 100)
  (chain console (log (vec-x v)))
  (chain console (log (vec-y v)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4)
        v3 (v+ v1 v2))
  (chain console (log (vec-x v3)))
  (chain console (log (vec-y v3)))

  (setf v1 (make-vector 10 5)
        v2 (v* v1 2))
  (chain console (log (vec-length v1)))
  (chain console (log (vec-length v2)))

  (setf v1 (make-vector 10 5)
        v2 (make-vector 3 4))
  (v+! v1 v2)
  (chain console (log (vec-x v1) (vec-y v1))))

(defun ep-8 ()
  "Velocity"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 2)
                                   (1+ (* (random) 4))
                                   (1+ (* (random) pi 2))))))
    (def-animation-loop update
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 10 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-9 ()
  "Acceleration"
  (let* ((num-particles 100)
         (particles (loop repeat num-particles
                          collect (make-particle
                                   (/ width 2)
                                   (/ height 3)
                                   (+ (* (random) 5) 2)
                                   (1+ (* (random) pi 2))
                                   0.1))))
    (def-animation-loop update
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) 4 0 (* pi 2) false)
        (ctx fill)))
    (update)))

(defun ep-10 ()
  "Advanced Acceleration"
  (let ((ship (make-particle (/ width 2) (/ height 2) 0 0))
        (thrust (make-vector 0 0))
        (angle 0)
        (turing-left nil)
        (turing-right nil)
        (thrusting nil))
    (chain document body (add-event-listener
                          "keydown"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting t)) ; up
                                (37 (setf turing-left t)) ; left
                                (39 (setf turing-right t)))))) ; right
    (chain document body (add-event-listener
                          "keyup"
                          #'(lambda (evt)
                              (case (@ evt key-code)
                                (38 (setf thrusting nil))
                                (37 (setf turing-left nil))
                                (39 (setf turing-right nil))))))
    (def-animation-loop update
      (when turing-left
        (decf angle 0.05))
      (when turing-right
        (incf angle 0.05))
      (setf (vec-angle thrust) angle
            (vec-length thrust) (if thrusting 0.1 0))
      (particle-accelerate! ship thrust)
        (particle-update! ship)
      (with-context
        (ctx translate (particle-x ship) (particle-y ship))
        (ctx rotate angle)
        (ctx begin-path)
        (ctx move-to 10 0)
        (ctx line-to -10 -7)
        (ctx line-to -10 7)
        (ctx line-to 10 0)
        (when thrusting
          (ctx move-to -10 0)
          (ctx line-to -18 0))
        (ctx stroke))
      (when (> (particle-x ship) width)
        (setf (particle-x ship) 0))
      (when (< (particle-x ship) 0)
        (setf (particle-x ship) width))
      (when (> (particle-y ship) height)
        (setf (particle-y ship) 0))
      (when (< (particle-y ship) 0)
        (setf (particle-y ship) height)))
    (update)))

(defun ep-11 ()
  "Gravity"
  (let ((sun (make-particle (/ width 2) (/ height 2) 0 0))
        (planet (make-particle (+ (/ width 2) 200) (/ height 2) 10 (/ pi -2))))
    (setf (particle-mass sun) 20000)
    (def-animation-loop update
      (particle-gravitate-to! planet sun)
      (particle-update! planet)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#ffff00")
      (ctx arc (particle-x sun) (particle-y sun) 20 0 (* pi 2) false)
      (ctx fill)
      (ctx begin-path)
      (setf (ctx-get fill-style) "#0000ff")
      (ctx arc (particle-x planet) (particle-y planet) 5 0 (* pi 2) false)
      (ctx fill))
    (update)))

(defun ep-12 ()
  "Edge Handling"
  (let* ((num-particles 100)
         (particles
           (loop repeat num-particles
                 collect (let ((particle (make-particle
                                          (/ width 2) height
                                          (+ (* (random) 8) 5) (+ (/ pi -2) (- (* (random) 0.2) 0.1))
                                          0.1)))
                           (setf (particle-radius particle) (+ (* (random) 10) 2)
                                 (particle-bounce particle) -0.9)
                           particle))))

    (defun wrap (p)
      (with-slots (radius) p
        (when (> (- (particle-x p) radius) width)
          (setf (particle-x p) (- radius)))
        (when (< (+ (particle-x p) radius) 0)
          (setf (particle-x p) (+ width radius)))
        (when (> (- (particle-y p) radius) height)
          (setf (particle-y p) (- radius)))
        (when (< (+ (particle-y p) radius) 0)
          (setf (particle-y p) (+ height radius)))))

    (defun remove-dead-particles (particles)
      (do ((i (1- (@ particles length)) (1- i)))
          ((< i 0))
        (let ((p (aref particles i)))
          (with-slots (radius) p
            (when (or (> (- (particle-x p) radius) width)
                      (< (+ (particle-x p) radius) 0)
                      (> (- (particle-y p) radius) height)
                      (< (+ (particle-y p) radius) 0))
              (chain particles (splice i 1)))))))

    (defun regenerate (p)
      (with-slots (radius velocity) p
        (when (> (- (particle-y p) radius) height)
          (setf (particle-x p) (/ width 2)
                (particle-y p) height
                (vec-length velocity) (+ (* (random) 8) 5)
                (vec-angle velocity) (+ (/ pi -2) (- (* (random) 0.2) 0.1))))))

    (defun bounce (p)
      (with-slots (velocity radius bounce) p
        (with-slots ((vx x) (vy y)) velocity
          (when (> (+ (particle-x p) radius) width)
            (setf (particle-x p) (- width radius)
                  vx (* vx bounce)))
          (when (< (- (particle-x p) radius) 0)
            (setf (particle-x p) radius
                  vx (* vx bounce)))
          (when (> (+ (particle-y p) radius) height)
            (setf (particle-y p) (- height radius)
                  vy (* vy bounce)))
          (when (< (- (particle-y p) radius) 0)
            (setf (particle-y p) radius
                  vy (* vy bounce))))))

    (def-animation-loop update ()
      (dolist (p particles)
        (particle-update! p)
        (ctx begin-path)
        (ctx arc (particle-x p) (particle-y p) (particle-radius p) 0 (* pi 2) false)
        (ctx fill)
        ;; (wrap p)
        ;; (regenerate p)
        (bounce p)
        )
      ;; (chain (remove-dead-particles particles))
      )
    (update)))


(setf (@ window onload) ep-12)
