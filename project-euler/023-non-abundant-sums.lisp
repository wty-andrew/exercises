(defun permutation (lst)
  (cond ((null lst) '())
        ((null (cdr lst)) (loop for i below (1+ (car lst))
                                collect (list i)))
        (t (let ((result '())
                 (n (car lst)))
             (dotimes (i (1+ n) result)
               (setf result (append result
                                    (mapcar #'(lambda (l) (cons i l)) (permutation (cdr lst))))))))))

(defun sum-divisors (num)
  "return the sum of divisors not include num itself"
  (let ((factors '())
        (powers '()))
    (do ((n 2 (1+ n)))
        ((= num 1))
      (do ((k 0 (1+ k)))
          ((/= (mod num n) 0) (when (> k 0)
                                (push n factors)
                                (push k powers)))
        (setf num (/ num n))))
    (apply #'+ (butlast (mapcar #'(lambda (l) (apply #'* (mapcar #'(lambda (x y) (expt x y))
                                                                 factors l)))
                                (permutation powers))))))

(defun abundant-p (num)
  (> (sum-divisors num) num))

;; (sum from 1 to 28123) - (all numbers that can be written as the sum of two abundant numbers)
(defun solution ()
  (let ((abundant-numbers (loop for n from 2 to 28123
                                when (abundant-p n)
                                  collect n))
        (valid-numbers (make-hash-table)))
    (dolist (i abundant-numbers)
      (dolist (j abundant-numbers)
        (when (<= (+ i j) 28123)
          (setf (gethash (+ i j) valid-numbers) t))))
    (- (/ (* (+ 1 28123) 28123) 2)
       (loop for key being the hash-keys of valid-numbers
             sum key))))
