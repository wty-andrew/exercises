(defun primep (n)
  (cond ((= n 2) t)
        ((or (= n 1) (zerop (mod n 2))) nil)
        (t (do ((m 3 (+ m 2)) )
               ((> m (isqrt n)) t)
             (when (zerop (mod n m))
               (return-from primep nil))))))

(defun consecutive-primes-count (a b)
  (do ((n 0 (1+ n))
       (count 0 (1+ count)))
      ((let ((num (+ (* n (+ a n)) b)))
         (or (< num 0) (not (primep num))))
       count)))

(defun solution ()
  (let ((best-count 0)
        (best-a)
        (best-b))
    (do ((a -1000 (1+ a)))
        ((> a 1000))
      (do ((b -1000 (1+ b)))
          ((> b 1000))
        (let ((count (consecutive-primes-count a b)))
          (when (> count best-count)
            (setf best-count count
                  best-a a
                  best-b b)))))
    (* best-a best-b)))
